--!optimization 2
-- [ RCM ] Severe UI Library v9.3 (Resizing & Snapping)
-- Features: Modular Host, Widget-to-Widget Snapping, Resizable Widgets
-- Update: Added Resize handle logic with edge snapping support.

local RCM = {}

print("[RCM] Library Initialized v9.3 Core")

-- [ 1 ] Configuration & Theme
RCM.Theme = {
    Background = Color3.new(0.08, 0.08, 0.08),
    SectionBg  = Color3.new(0.12, 0.12, 0.12),
    Border     = Color3.new(0.0, 0.0, 0.0),
    Accent     = Color3.new(0.8039, 0.0, 0.4980),
    Text       = Color3.new(0.9, 0.9, 0.9),
    TextDim    = Color3.new(0.5, 0.5, 0.5),
    Hover      = Color3.new(0.16, 0.16, 0.16),
    TooltipBg  = Color3.new(0.05, 0.05, 0.05),
    SnapLine   = Color3.new(0.2, 0.8, 0.2), 
    InfoWinBg  = Color3.new(0.1, 0.1, 0.1),
    Link       = Color3.new(0.4, 0.6, 1),
    Section    = Color3.new(0.25, 0.25, 0.25),
    Negative   = Color3.new(1, 0.3, 0.3),
    ResizeHandle = Color3.new(0.3, 0.3, 0.3)
}

RCM.Layer = { Base=0, Section=1, Item=2, Text=3, Widget=10, Popup=20, InfoWin=100, Snap=150, Notif=200, Tooltip=300 }
local WIN_W, COL_W = 550, 260

-- [ 2 ] State & Registry
RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false, MouseHeld = false,
    RightMouseDown = false, RightMouseHeld = false,
    ToggleKey = "Delete", LastToggle = 0,
    ActiveTooltip = nil, ActivePopup = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    Watermark = { Visible = true, Text = "Severe UI", Extra = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) },
    InfoWindows = {},
    InputBusy = false,
    Snapping = { ActiveLines = {} },
    LastTick = 0, FrameCount = 0, CurrentFPS = 60
}

RCM.Binders = {}
RCM.Notifications = {}
RCM.Windows = {} 
RCM.Widgets = {} 
RCM.Flags = {} 

-- [ 3 ] Helpers
function RCM.Rect(pos, size, color, alpha) DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1) end
function RCM.Label(pos, text, color, center) DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy") end
function RCM.Line(a, b, color, alpha, thickness) DrawingImmediate.Line(a, b, color, alpha, 1, thickness or 1) end
function RCM.Triangle(a, b, c, color, alpha) DrawingImmediate.FilledTriangle(a, b, c, color, alpha or 1) end

local function FitText(text, maxWidth)
    local charWidth = 7 
    if (#text * charWidth) > maxWidth then return string.sub(text, 1, math.floor(maxWidth / charWidth) - 2) .. ".." end
    return text
end

local function WrapText(str, maxChars)
    local lines, currentLine = {}, ""
    for word in str:gmatch("%S+") do
        if #currentLine + #word + 1 > maxChars then table.insert(lines, currentLine); currentLine = word
        else if currentLine == "" then currentLine = word else currentLine = currentLine .. " " .. word end end
    end
    if currentLine ~= "" then table.insert(lines, currentLine) end
    if #lines == 0 then lines = {str} end
    return lines
end

-- [ 4 ] Core Logic
function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local lDown = isleftpressed()
    if lDown and not self.State.MouseDown then self.State.MouseDown = true
    elseif lDown and self.State.MouseDown then self.State.MouseHeld = true
    elseif not lDown then
        self.State.MouseDown = false; self.State.MouseHeld = false
        self.State.Watermark.Dragging = false; self.State.KeybindList.Dragging = false
        for _, win in ipairs(self.State.InfoWindows) do win.dragging = false end
        for _, win in ipairs(RCM.Windows) do win.dragging = false end
        for _, wid in ipairs(RCM.Widgets) do wid.dragging = false; wid.resizing = false end
        self.State.Snapping.ActiveLines = {} 
    end

    local rDown = isrightpressed()
    if rDown and not self.State.RightMouseDown then self.State.RightMouseDown = true
    elseif rDown and self.State.RightMouseDown then self.State.RightMouseHeld = true
    elseif not rDown then self.State.RightMouseDown = false; self.State.RightMouseHeld = false end

    if self.State.MouseDown and not self.State.MouseHeld and self.State.ActivePopup then
        local p = self.State.ActivePopup
        local size = p.Size or vector.create(80, 64, 0)
        if not self:IsMouseOver(p.Pos, size) then self.State.ActivePopup = nil end
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then for _, k in ipairs(keys) do if k == self.State.ToggleKey then isTogglePressed = true break end end end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled; self.State.LastToggle = tick()
    end

    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount; self.State.FrameCount = 0; self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end
    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" and k ~= "RightMouse" then
                    bind.key = k; bind.listening = false;
                    if bind.callback then bind.callback(bind.key) end
                    if bind.flag then RCM.Flags[bind.flag] = { Key = k, Mode = bind.mode } end
                end
            end
        else
            local isKeyDown = keyMap[bind.key] == true
            if bind.mode == "Always" then bind.active = true
            elseif bind.mode == "Hold" then bind.active = isKeyDown
            elseif bind.mode == "Toggle" then if isKeyDown and not bind.lastState then bind.active = not bind.active end end
            bind.lastState = isKeyDown
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x and m.y >= pos.y and m.y <= pos.y + size.y
end

function RCM:SetWatermark(text) self.State.Watermark.Text = text end
function RCM:Notify(msg, duration) table.insert(self.Notifications, {id = tick()..math.random(), text = msg, duration = duration or 3, start = tick(), alpha = 0}) end

-- ============================================================================
-- [ 5 ] SNAPPING & RESIZING SYSTEM
-- ============================================================================

-- Helper: Get snap targets from all other visible objects
function RCM:GetSnapTargets(currentObj)
    local screen = self.State.ScreenSize
    local targetsX = { 0, screen.x / 2, screen.x } 
    local targetsY = { 0, screen.y / 2, screen.y } 
    
    local function Add(other)
        if other == currentObj then return end
        if not other.pos or not other.size then return end
        table.insert(targetsX, other.pos.x)
        table.insert(targetsX, other.pos.x + other.size.x)
        table.insert(targetsY, other.pos.y)
        table.insert(targetsY, other.pos.y + other.size.y)
    end

    for _, w in ipairs(self.Windows) do Add(w) end
    for _, w in ipairs(self.Widgets) do Add(w) end
    if self.State.Watermark.Visible then
        local w = self.State.Watermark; local t = w.Text; if w.Extra then t=t.."..." end
        Add({pos=w.Pos, size=vector.create((7*#t)+20, 22, 0)}) 
    end
    return targetsX, targetsY
end

-- Logic for DRAGGING (Moves Position)
function RCM:CalculateDragSnap(currentObj, rawPos)
    local snapPos = rawPos
    local objSize = currentObj.size or vector.create(0,0,0)
    local targetsX, targetsY = self:GetSnapTargets(currentObj)
    local screen = self.State.ScreenSize
    local threshold, lockDist = 15, 8
    
    self.State.Snapping.ActiveLines = {} -- Reset lines

    local anchorsX = { 0, objSize.x / 2, objSize.x }
    local anchorsY = { 0, objSize.y / 2, objSize.y }

    local function CheckAxis(val, anchors, targets, isX)
        local best = nil; local minD = threshold
        for _, off in ipairs(anchors) do
            local pt = val + off
            for _, t in ipairs(targets) do
                local diff = math.abs(pt - t)
                if diff < threshold then
                    local alpha = 1 - (diff / threshold)
                    local ls, le
                    if isX then ls=vector.create(t,0,RCM.Layer.Snap); le=vector.create(t,screen.y,0)
                    else ls=vector.create(0,t,RCM.Layer.Snap); le=vector.create(screen.x,t,0) end
                    table.insert(self.State.Snapping.ActiveLines, {A=ls, B=le, Alpha=alpha})
                    if diff < lockDist and diff < minD then minD = diff; best = t - off end
                end
            end
        end
        return best or val
    end

    return vector.create(CheckAxis(rawPos.x, anchorsX, targetsX, true), CheckAxis(rawPos.y, anchorsY, targetsY, false), 0)
end

-- Logic for RESIZING (Changes Size, Anchored Top-Left)
function RCM:CalculateResizeSnap(currentObj, rawSize)
    local snapSize = rawSize
    local pos = currentObj.pos
    local targetsX, targetsY = self:GetSnapTargets(currentObj)
    local screen = self.State.ScreenSize
    local threshold, lockDist = 15, 8
    
    self.State.Snapping.ActiveLines = {}

    -- Only check the Bottom-Right corner against targets
    local function CheckAxis(currentSizeVal, posVal, targets, isX)
        local edge = posVal + currentSizeVal -- Bottom or Right edge
        local best = nil; local minD = threshold
        
        for _, t in ipairs(targets) do
            local diff = math.abs(edge - t)
            if diff < threshold then
                local alpha = 1 - (diff / threshold)
                local ls, le
                if isX then ls=vector.create(t,0,RCM.Layer.Snap); le=vector.create(t,screen.y,0)
                else ls=vector.create(0,t,RCM.Layer.Snap); le=vector.create(screen.x,t,0) end
                table.insert(self.State.Snapping.ActiveLines, {A=ls, B=le, Alpha=alpha})
                
                if diff < lockDist and diff < minD then
                    minD = diff
                    best = t - posVal -- New size is (Target - StartPos)
                end
            end
        end
        return best or currentSizeVal
    end

    snapSize = vector.create(
        math.max(CheckAxis(rawSize.x, pos.x, targetsX, true), currentObj.minSize.x),
        math.max(CheckAxis(rawSize.y, pos.y, targetsY, false), currentObj.minSize.y),
        0
    )
    return snapSize
end

function RCM:DrawSnapLines()
    if not self.State.InputBusy then return end 
    for _, line in ipairs(self.State.Snapping.ActiveLines) do
        RCM.Line(line.A, line.B, self.Theme.SnapLine, line.Alpha, 1)
        if line.Alpha > 0.5 then RCM.Line(line.A, line.B, self.Theme.SnapLine, line.Alpha * 0.3, 3) end
    end
end

-- ============================================================================
-- [ 6 ] WIDGET & WINDOW SYSTEM
-- ============================================================================

function RCM:CreateWidget(props)
    local widget = {
        name = props.Name or "Widget",
        pos = props.Position or vector.create(100, 100, 0),
        size = props.Size or vector.create(100, 100, 0),
        minSize = props.MinSize or vector.create(50, 30, 0), -- Prevent inversion
        resizable = (props.Resizable == nil and true) or props.Resizable, -- Default true
        draw = props.Draw, 
        dragging = false, resizing = false,
        dragOffset = vector.create(0,0,0)
    }
    table.insert(self.Widgets, widget)
    return widget
end

function RCM:HandleDraggable(obj)
    local click = self.State.MouseDown and not self.State.MouseHeld
    
    if not self.State.InputBusy then
        -- 1. Check Resize (Bottom Right Corner)
        if obj.resizable then
            local resizeHandleSize = 15
            local handlePos = vector.create(obj.pos.x + obj.size.x - resizeHandleSize, obj.pos.y + obj.size.y - resizeHandleSize, 0)
            
            if click and self:IsMouseOver(handlePos, vector.create(resizeHandleSize, resizeHandleSize, 0)) then
                obj.resizing = true
                -- Offset isn't strictly needed for resize calc but good for delta if we wanted relative resizing
                -- Here we assume absolute snapping
            end
        end

        -- 2. Check Drag (Rest of body)
        if not obj.resizing and click and self:IsMouseOver(obj.pos, obj.size) then
            obj.dragging = true
            obj.dragOffset = vector.create(self.State.MousePos.x - obj.pos.x, self.State.MousePos.y - obj.pos.y, 0)
        end
    end
    
    if obj.resizing then
        if self.State.MouseDown then
            local rawSize = vector.create(self.State.MousePos.x - obj.pos.x, self.State.MousePos.y - obj.pos.y, 0)
            obj.size = self:CalculateResizeSnap(obj, rawSize)
            self.State.InputBusy = true
        else
            obj.resizing = false
        end
    elseif obj.dragging then
        if self.State.MouseDown then
            local rawPos = vector.create(self.State.MousePos.x - obj.dragOffset.x, self.State.MousePos.y - obj.dragOffset.y, 0)
            obj.pos = self:CalculateDragSnap(obj, rawPos) 
            self.State.InputBusy = true
        else
            obj.dragging = false
        end
    end

    -- Draw Resize Handle if applicable
    if obj.resizable and (obj.dragging or obj.resizing or self:IsMouseOver(obj.pos, obj.size)) then
        local p = obj.pos; local s = obj.size; local hs = 10
        local c = obj.resizing and self.Theme.Accent or self.Theme.ResizeHandle
        -- Draw triangle at bottom right
        RCM.Triangle(
            vector.create(p.x + s.x, p.y + s.y, RCM.Layer.Widget+5),
            vector.create(p.x + s.x - hs, p.y + s.y, RCM.Layer.Widget+5),
            vector.create(p.x + s.x, p.y + s.y - hs, RCM.Layer.Widget+5),
            c, 1
        )
    end
end

-- Main Window Logic
local function LibraryWindow(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end
    if RCM.Windows[1] then RCM.Windows[1].name = props.Name or RCM.Windows[1].name; return RCM.Windows[1] end

    local window = { name = props.Name or "UI", pos = props.Position or vector.create(200,200,0), size = vector.create(WIN_W, 30, 0), dragging=false, dragOffset=vector.create(0,0,0), pages={}, activePage=1 }

    function window:Draw()
        if not RCM.State.Enabled then return end
        
        local page = self.pages[self.activePage]; local lY, rY = 55, 55
        if page then
            for _, s in ipairs(page.sections) do
                local h = 25
                for _, it in ipairs(s.items) do
                    local add = 24
                    if it.type == "dropdown" and it.open then add = add + (#it.options * 20) end
                    if it.type == "colorpicker" and it.open then add = add + 70 end
                    h = h + add
                end
                if s.side == "Left" then s.ry = lY; lY=lY+h+10 else s.ry = rY; rY=rY+h+10 end
            end
        end
        local totalH = math.max(lY, rY)
        self.size = vector.create(WIN_W, totalH + 10, 0)

        -- Windows are generally fixed width in this lib style, but we apply DragSnap
        local click = self.State.MouseDown and not self.State.MouseHeld
        if not self.State.InputBusy and click and self:IsMouseOver(self.pos, self.size) then
            self.dragging = true; self.dragOffset = vector.create(self.State.MousePos.x - self.pos.x, self.State.MousePos.y - self.pos.y, 0)
        end
        if self.dragging then
            if self.State.MouseDown then
                local raw = vector.create(self.State.MousePos.x - self.dragOffset.x, self.State.MousePos.y - self.dragOffset.y, 0)
                self.pos = self:CalculateDragSnap(self, raw)
                self.State.InputBusy = true
            else self.dragging = false end
        end

        local x, y = self.pos.x, self.pos.y
        if RCM.State.InputBusy and not self.dragging then click = false end

        RCM.Rect(vector.create(x,y,0), self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x+1,y+1,1), vector.create(WIN_W-2, totalH+8,0), RCM.Theme.Background, 1)
        RCM.Rect(vector.create(x,y,2), vector.create(WIN_W,2,0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x+10,y+5,3), self.name, RCM.Theme.Text)
        RCM.Rect(vector.create(x+10,y+45,3), vector.create(WIN_W-20,1,0), RCM.Theme.Section, 1)

        local tx = 10
        for i, pg in ipairs(self.pages) do
            local w = (7*#pg.name)+20
            if click and RCM:IsMouseOver(vector.create(x+tx,y+25,0), vector.create(w,20,0)) then self.activePage = i end
            RCM.Label(vector.create(x+tx+5,y+25,3), pg.name, (self.activePage==i) and RCM.Theme.Accent or RCM.Theme.TextDim)
            if self.activePage==i then RCM.Rect(vector.create(x+tx+5,y+40,3), vector.create(w-10,1,0), RCM.Theme.Accent, 1) end
            tx = tx + w
        end

        if page then
            for _, sect in ipairs(page.sections) do
                local sx = (sect.side == "Left") and (x+12) or (x+12+COL_W+10); local sy = y+sect.ry
                local sh = 25
                for _, it in ipairs(sect.items) do
                    local add = 24
                    if it.type=="dropdown" and it.open then add=add+(#it.options*20) end
                    if it.type=="colorpicker" and it.open then add=add+70 end
                    sh = sh + add
                end
                
                RCM.Rect(vector.create(sx,sy,1), vector.create(COL_W,sh,0), RCM.Theme.Border, 1)
                RCM.Rect(vector.create(sx+1,sy+1,1), vector.create(COL_W-2,sh-2,0), RCM.Theme.SectionBg, 1)
                RCM.Rect(vector.create(sx,sy,2), vector.create(COL_W,2,0), RCM.Theme.Accent, 1)
                RCM.Label(vector.create(sx+8,sy+5,3), sect.name, RCM.Theme.Text)

                local cy = sy + 25
                for _, item in ipairs(sect.items) do
                    local nmX, valX = sx+10, sx+COL_W-15
                    local iH = 24
                    local itemPos = vector.create(sx+5, cy, 0)
                    local hover = RCM:IsMouseOver(itemPos, vector.create(COL_W-10, iH-4, 0))
                    local iClick = hover and click
                    if hover then RCM.Rect(itemPos, vector.create(COL_W-10, iH-4, 0), RCM.Theme.Hover, 0.5) end

                    if item.type == "toggle" then
                        if iClick then item.value = not item.value; if item.callback then item.callback(item.value) end; if item.flag then RCM.Flags[item.flag] = item.value end end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX-10, cy+5, 3), vector.create(10,10,0), RCM.Theme.Border, 1)
                        RCM.Rect(vector.create(valX-9, cy+6, 3), vector.create(8,8,0), item.value and RCM.Theme.Accent or RCM.Theme.Section, 1)

                    elseif item.type == "slider" then
                        if hover and isleftpressed() and not RCM.State.InputBusy then
                            local pct = math.clamp((RCM.State.MousePos.x - (valX - 100)) / 100, 0, 1)
                            local nv = math.floor(item.min + (item.max - item.min) * pct)
                            if nv ~= item.value then 
                                item.value = nv; if item.callback then item.callback(nv) end; if item.flag then RCM.Flags[item.flag] = nv end
                            end
                        end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - 120, cy + 3, 3), tostring(item.value), RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(100, 4, 0), RCM.Theme.Background, 1)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(((item.value - item.min)/(item.max - item.min))*100, 4, 0), RCM.Theme.Accent, 1)

                    elseif item.type == "dropdown" then
                        if iClick then item.open = not item.open end
                        local dispText = item.selected
                        if item.multi then
                            local active = {}
                            for k,v in pairs(item.selected) do if v then table.insert(active, k) end end
                            if #active == 0 then dispText = "None" elseif #active > 2 then dispText = #active .. " Selected" else dispText = table.concat(active, ", ") end
                        end
                        RCM.Label(vector.create(nmX, cy+3, 3), FitText(item.name, 120), RCM.Theme.Text)
                        RCM.Label(vector.create(valX-(7*#dispText), cy+3, 3), dispText, RCM.Theme.Accent)
                        if item.open then
                            local dy = cy + 24
                            for _, opt in ipairs(item.options) do
                                local oPos = vector.create(sx+15, dy, 0)
                                if RCM:IsMouseOver(oPos, vector.create(230, 18, 0)) then
                                    RCM.Rect(oPos, vector.create(230, 18, 0), RCM.Theme.Hover, 0.5)
                                    if click then
                                        if item.multi then item.selected[opt] = not item.selected[opt]; if item.callback then item.callback(item.selected) end; if item.flag then RCM.Flags[item.flag] = item.selected end
                                        else item.selected = opt; item.open = false; if item.callback then item.callback(opt) end; if item.flag then RCM.Flags[item.flag] = opt end end
                                    end
                                end
                                local isSel = false; if item.multi then isSel = item.selected[opt] else isSel = (item.selected == opt) end
                                RCM.Label(vector.create(sx+20, dy+2, 20), opt, isSel and RCM.Theme.Accent or RCM.Theme.Text)
                                dy = dy + 20
                            end
                            iH = iH + (#item.options * 20)
                        end
                        
                    elseif item.type == "button" then
                        if iClick and item.callback then item.callback() end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, hover and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "colorpicker" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 15, cy + 5, 3), vector.create(20, 10, 0), item.color, 1)
                        if item.open then
                            local py = cy + 24
                            local function slider(c, v, m)
                                if RCM:IsMouseOver(vector.create(sx+15, py, 0), vector.create(COL_W-30, 15, 0)) and isleftpressed() then
                                    local p = math.clamp((RCM.State.MousePos.x - (sx+40)) / 150, 0, 1)
                                    v = math.floor(p * m)
                                end
                                RCM.Label(vector.create(sx+20, py, 20), c, RCM.Theme.Text)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create(150, 4, 0), RCM.Theme.Background, 1)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create((v/m)*150, 4, 0), RCM.Theme.Accent, 1)
                                py = py + 20
                                return v
                            end
                            local r = slider("R", math.floor(item.color.R*255), 255)
                            local g = slider("G", math.floor(item.color.G*255), 255)
                            local b = slider("B", math.floor(item.color.B*255), 255)
                            local nc = Color3.fromRGB(r,g,b)
                            if nc ~= item.color then item.color = nc; if item.callback then item.callback(nc) end; if item.flag then RCM.Flags[item.flag] = {R=nc.R, G=nc.G, B=nc.B} end end
                            iH = iH + 70
                        end
                    
                    elseif item.type == "binder" then
                        if iClick then item.listening = not item.listening end
                        if (RCM.State.RightMouseDown and not RCM.State.RightMouseHeld) and hover then RCM.State.ActivePopup = { BindItem = item, Pos = RCM.State.MousePos } end
                        local txt = "[" .. (item.listening and "..." or item.key) .. "]"
                        local keyW = (7 * #txt)
                        RCM.Label(vector.create(nmX, cy + 3, 3), FitText(item.name, 230 - keyW), RCM.Theme.Text)
                        RCM.Label(vector.create(valX - keyW, cy + 3, 3), txt, item.listening and RCM.Theme.Accent or RCM.Theme.TextDim)
                    end

                    if item.tooltip then
                         local tipPos = vector.create(nmX + (7*#item.name) + 8, cy+3, 3)
                         RCM.Label(tipPos, "(?)", RCM.Theme.TextDim)
                         if RCM:IsMouseOver(tipPos, vector.create(15,13,0)) then RCM.State.ActiveTooltip = item.tooltip end
                    end
                    cy = cy + iH
                end
            end
        end
    end
    
    function window:Page(p)
        for _, pg in ipairs(self.pages) do if pg.name == p.Name then return pg end end
        local pg = {name=p.Name, sections={}}
        function pg:Section(p)
            local sec = {name=p.Name, side=p.Side or "Left", items={}}
            function sec:Toggle(p) table.insert(sec.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or false end end
            function sec:Slider(p) table.insert(sec.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or p.Min end end
            function sec:Dropdown(p) local sel = p.Default; if p.Multi and type(sel) ~= "table" then sel = {} end; table.insert(sec.items, {type="dropdown", name=p.Name, options=p.Options, selected=sel, open=false, multi=p.Multi, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = sel end end
            function sec:Button(p) table.insert(sec.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function sec:ColorPicker(p) local c = p.Default or Color3.new(1,1,1); table.insert(sec.items, {type="colorpicker", name=p.Name, color=c, open=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = {R=c.R, G=c.G, B=c.B} end end
            function sec:Binder(p) local b = {type="binder", name=p.Name, key=p.Default or "None", mode="Hold", active=false, listening=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}; table.insert(sec.items, b); table.insert(RCM.Binders, b); if p.Flag then RCM.Flags[p.Flag] = { Key = b.key, Mode = b.mode } end end
            table.insert(pg.sections, sec)
            return sec
        end
        table.insert(self.pages, pg)
        return pg
    end
    return window
end

function RCM:CreateWindow(p) local w=LibraryWindow(p); table.insert(self.Windows, w); return w end

-- [ 7 ] INFO & MISC
function RCM:OpenInfoWindow(title, content)
    for i, win in ipairs(self.State.InfoWindows) do if win.title == title then table.remove(self.State.InfoWindows, i) break end end
    local processedLines = {}
    if type(content) == "table" then
        for _, item in ipairs(content) do
            if type(item) == "string" then for _, l in ipairs(WrapText(item, 40)) do table.insert(processedLines, {type="text", text=l}) end
            elseif type(item) == "table" then
                if item.Text then table.insert(processedLines, {type="link", text=item.Text, callback=item.Callback})
                elseif item.Type == "sep" then table.insert(processedLines, {type="sep"}) end
            end
        end
    end
    local last = self.State.InfoWindows[#self.State.InfoWindows]
    local spawn = last and vector.create(last.pos.x+20, last.pos.y+20, 0) or vector.create((self.State.ScreenSize.x/2)-150, (self.State.ScreenSize.y/2)-100, 0)
    local win = {id=tick()..math.random(), title=title, items=processedLines, pos=spawn, dragging=false, dragOffset=vector.create(0,0,0), size=vector.create(300, 200, 0)} -- Added size for snap logic
    table.insert(self.State.InfoWindows, win)
end

function RCM:DrawInfoWindows()
    if not self.State.Enabled then return end
    for i = #self.State.InfoWindows, 1, -1 do
        local win = self.State.InfoWindows[i]
        local w, hh, ch = 300, 22, 10
        for _, it in ipairs(win.items) do ch=ch+(it.type=="sep" and 8 or 16) end
        local th = hh + ch
        win.size = vector.create(w, th, 0) 
        
        -- Logic
        if not self.State.InputBusy or win.dragging then
            local click = self.State.MouseDown and not self.State.MouseHeld
            if click and self:IsMouseOver(vector.create(win.pos.x+w-20, win.pos.y+2, 0), vector.create(18,18,0)) then table.remove(self.State.InfoWindows, i); return end
            if self:IsMouseOver(win.pos, vector.create(w, hh, 0)) and click then win.dragging=true; win.dragOffset=vector.create(self.State.MousePos.x-win.pos.x, self.State.MousePos.y-win.pos.y, 0); table.insert(self.State.InfoWindows, table.remove(self.State.InfoWindows, i)); return end
            if click then
                local cy = win.pos.y + hh + 5
                for _, item in ipairs(win.items) do
                    if item.type=="link" and self:IsMouseOver(vector.create(win.pos.x+10,cy,0), vector.create(7*#item.text, 14, 0)) then if item.callback then item.callback() end end
                    cy = cy + (item.type=="sep" and 8 or 16)
                end
            end
        end
        
        if win.dragging then 
            if self.State.MouseDown then
                local raw = vector.create(self.State.MousePos.x-win.dragOffset.x, self.State.MousePos.y-win.dragOffset.y, 0)
                win.pos = self:CalculateDragSnap(win, raw) 
                self.State.InputBusy=true 
            else win.dragging = false end
        end

        -- Render
        RCM.Rect(win.pos, win.size, self.Theme.Border, 1)
        RCM.Rect(vector.create(win.pos.x+1,win.pos.y+1,RCM.Layer.InfoWin+i), vector.create(w-2, th-2, 0), self.Theme.InfoWinBg, 1)
        RCM.Rect(win.pos, vector.create(w, 2, 0), self.Theme.Accent, 1)
        RCM.Label(vector.create(win.pos.x+10, win.pos.y+4, RCM.Layer.InfoWin+i+1), win.title, self.Theme.Text)
        RCM.Label(vector.create(win.pos.x+w-15, win.pos.y+4, RCM.Layer.InfoWin+i+1), "X", self.Theme.Negative)
        
        local cy = win.pos.y + hh + 5
        for _, item in ipairs(win.items) do
            local z = RCM.Layer.InfoWin+i+1
            if item.type == "text" then RCM.Label(vector.create(win.pos.x+10, cy, z), item.text, self.Theme.TextDim); cy = cy + 16
            elseif item.type == "link" then 
                local col = self.Theme.Link; local lw = 7*#item.text
                if self:IsMouseOver(vector.create(win.pos.x+10, cy, 0), vector.create(lw, 14, 0)) then col = self.Theme.Accent end
                RCM.Label(vector.create(win.pos.x+10, cy, z), item.text, col); RCM.Rect(vector.create(win.pos.x+10, cy+13, z), vector.create(lw,1,0), col, 1); cy = cy + 16
            elseif item.type == "sep" then RCM.Rect(vector.create(win.pos.x+10, cy+3, z), vector.create(w-20,1,0), self.Theme.Border, 0.5); cy = cy + 8 end
        end
    end
end

function RCM:DrawStandardInterface()
    if self.State.Watermark.Visible then
        local p, t = self.State.Watermark.Pos, self.State.Watermark.Text
        if self.State.Watermark.Extra then 
            local plrName = "Unknown"
            if game and game:GetService("Players") and game:GetService("Players").LocalPlayer then
                plrName = game:GetService("Players").LocalPlayer.Name
            end
            t = t .. " | User: " .. plrName 
        end
        local sz = vector.create((7*#t)+20, 22, 0)
        if self.State.Enabled and not self.State.InputBusy then
            if self.State.MouseDown and not self.State.MouseHeld and self:IsMouseOver(p, sz) then self.State.Watermark.Dragging = true; self.State.Watermark.Offset = vector.create(self.State.MousePos.x-p.x, self.State.MousePos.y-p.y, 0) end
            if self.State.Watermark.Dragging then
                if self.State.MouseDown then
                    local raw = vector.create(self.State.MousePos.x-self.State.Watermark.Offset.x, self.State.MousePos.y-self.State.Watermark.Offset.y, 0)
                    local dummy = { pos=raw, size=sz } 
                    p = self:CalculateDragSnap(dummy, raw); self.State.Watermark.Pos = p
                    self.State.InputBusy = true
                else self.State.Watermark.Dragging = false end
            end
        end
        RCM.Rect(p, sz, self.Theme.Border, 1); RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(sz.x-2,sz.y-2,0), self.Theme.Background, 1)
        RCM.Rect(p, vector.create(sz.x,2,0), self.Theme.Accent, 1); RCM.Label(vector.create(p.x+10,p.y+4,3), t, self.Theme.Text)
    end
    
    local startY = 50
    for i=#self.Notifications, 1, -1 do
        local n = self.Notifications[i]; local el = tick()-n.start; local rem = n.duration-el
        if rem <= 0 then table.remove(self.Notifications, i) else
            local bw = (7*#n.text)+20; local px = self.State.ScreenSize.x - bw - 20
            RCM.Rect(vector.create(px,startY,200), vector.create(bw,26,0), self.Theme.Border, 1)
            RCM.Rect(vector.create(px+1,startY+1,200), vector.create(bw-2,24,0), self.Theme.Background, 1)
            RCM.Label(vector.create(px+10,startY+5,200), n.text, RCM.Theme.Text)
            RCM.Rect(vector.create(px+1,startY+23,200), vector.create((bw-2)*(rem/n.duration),2,0), RCM.Theme.Accent, 1)
            startY = startY + 35
        end
    end

    if self.State.KeybindList.Visible and self.State.Enabled then
        local itemsToShow = {}
        for _, bind in ipairs(RCM.Binders) do if self.State.KeybindList.Mode == "Always" or (self.State.KeybindList.Mode == "Active" and bind.active) then table.insert(itemsToShow, bind) end end
        if #itemsToShow > 0 then
            local p = self.State.KeybindList.Pos; local mw = 130; for _, b in ipairs(itemsToShow) do local tw = (7*#b.name)+(7*#b.key)+50; if tw>mw then mw=tw end end
            local th = 24 + (#itemsToShow * 18) + 4
            local sz = vector.create(mw, th, 0)
            if not self.State.InputBusy and self.State.MouseDown and not self.State.MouseHeld and self:IsMouseOver(p, vector.create(mw, 24, 0)) then self.State.KeybindList.Dragging=true; self.State.KeybindList.Offset = vector.create(self.State.MousePos.x-p.x, self.State.MousePos.y-p.y, 0) end
            if self.State.KeybindList.Dragging then 
                if self.State.MouseDown then
                    local raw = vector.create(self.State.MousePos.x-self.State.KeybindList.Offset.x, self.State.MousePos.y-self.State.KeybindList.Offset.y, 0)
                    local dummy = { pos=raw, size=sz }
                    self.State.KeybindList.Pos = self:CalculateDragSnap(dummy, raw)
                    p=self.State.KeybindList.Pos; self.State.InputBusy=true 
                else self.State.KeybindList.Dragging=false end
            end
            RCM.Rect(p, sz, self.Theme.Border, 1); RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(mw-2, th-2, 0), self.Theme.Background, 1)
            RCM.Rect(p, vector.create(mw, 2, 0), self.Theme.Accent, 1); RCM.Label(vector.create(p.x+(mw/2)-20, p.y+5, 3), "Keybinds", self.Theme.Text)
            local ky = p.y + 26
            for _, b in ipairs(itemsToShow) do
                local kt = "["..b.key.."]"; local mt = (b.mode=="Hold" and "[H]") or (b.mode=="Toggle" and "[T]") or "[A]"
                RCM.Label(vector.create(p.x+5, ky, 3), b.name, self.Theme.Text)
                RCM.Label(vector.create(p.x+mw-(7*#kt)-(7*#mt)-10, ky, 3), kt..mt, b.active and self.Theme.Accent or self.Theme.TextDim)
                ky = ky + 18
            end
        end
    end
end

function RCM:DrawPopup()
    if not self.State.ActivePopup then return end
    local p = self.State.ActivePopup; local bind = p.BindItem; local pos = p.Pos
    local opts = {"Hold", "Toggle", "Always"}; local w, h = 80, (#opts*20)+4
    RCM.Rect(pos, vector.create(w, h, 20), self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x+1, pos.y+1, 20), vector.create(w-2, h-2, 0), self.Theme.Background, 1)
    local cy = pos.y + 2
    for _, m in ipairs(opts) do
        local op = vector.create(pos.x+2, cy, 20); local os = vector.create(w-4, 18, 0)
        local hov = self:IsMouseOver(op, os)
        if hov then
            RCM.Rect(op, os, self.Theme.Accent, 0.8)
            if self.State.MouseDown and not self.State.MouseHeld then bind.mode = m; self.State.ActivePopup = nil; return end
        end
        RCM.Label(vector.create(pos.x+5, cy+2, 21), m, (bind.mode==m or hov) and self.Theme.Text or self.Theme.TextDim)
        cy = cy + 20
    end
end

function RCM:Init()
    local ren = RunService.Render or game:GetService("RunService").RenderStepped
    ren:Connect(function()
        self.State.InputBusy = false
        self.State.ActiveTooltip = nil 
        
        self:UpdateInput()
        self:UpdateBinders()
        
        self:DrawStandardInterface()
        for _, w in ipairs(self.Windows) do w:Draw() end
        self:HandleDraggableWidgets() 
        
        self:DrawInfoWindows()
        self:DrawPopup()
        self:DrawSnapLines()
        
        if self.State.ActiveTooltip and not self.State.ActivePopup and self.State.Enabled then
            local t, m = self.State.ActiveTooltip, self.State.MousePos
            local w = (8*#t)+12
            RCM.Rect(vector.create(m.x+12,m.y+12,RCM.Layer.Tooltip), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(m.x+13,m.y+13,RCM.Layer.Tooltip), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(m.x+17,m.y+15,RCM.Layer.Tooltip), t, RCM.Theme.Text)
        end
    end)
end

function RCM:HandleDraggableWidgets()
    for _, wid in ipairs(self.Widgets) do
        self:HandleDraggable(wid)
        wid.draw()
    end
end

RCM:Init()
return RCM
