--!optimization 2
-- [ RCM ] Severe UI Library v3.0
-- Features: Keybind List (Always/Active modes), Binders (Hold logic), Watermark, Config

local RCM = {}
local Library = {}

-- [ 1 ] Configuration
RCM.Theme = {
    Background = Color3.new(0.104, 0.104, 0.104),
    Border     = Color3.new(0.023, 0.023, 0.023),
    Accent     = Color3.new(0.8039, 0.0, 0.4980),
    Text       = Color3.new(1, 1, 1),
    TextDim    = Color3.new(0.5, 0.5, 0.5),
    Section    = Color3.new(0.588, 0.588, 0.588),
    Hover      = Color3.new(0.2, 0.2, 0.2),
    TooltipBg  = Color3.new(0.05, 0.05, 0.05)
}

RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false,
    MouseHeld = false,
    ToggleKey = "Delete",
    LastToggle = 0,
    ActiveTooltip = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    
    -- FPS State
    LastTick = 0, FrameCount = 0, CurrentFPS = 60,

    -- HUD States
    Watermark = { Visible = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) }
}

-- Registry for logic updates (Binders need to run when menu is closed)
RCM.Binders = {} 

-- [ 2 ] Helpers
function RCM.Rect(pos, size, color, alpha)
    DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1)
end

function RCM.Label(pos, text, color, center)
    DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy")
end

function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local currentDown = isleftpressed()
    if currentDown and not self.State.MouseDown then
        self.State.MouseDown = true
    elseif currentDown and self.State.MouseDown then
        self.State.MouseHeld = true
    elseif not currentDown then
        self.State.MouseDown = false
        self.State.MouseHeld = false
        self.State.Watermark.Dragging = false
        self.State.KeybindList.Dragging = false
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then
        for _, k in ipairs(keys) do
            if k == self.State.ToggleKey then isTogglePressed = true break end
        end
    end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled
        self.State.LastToggle = tick()
    end

    -- FPS Logic
    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount
        self.State.FrameCount = 0
        self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end

    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            -- Rebinding logic
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" then
                    bind.key = k
                    bind.listening = false
                end
            end
        else
            -- Active state logic (Hold mode)
            local isActive = keyMap[bind.key] == true
            if bind.active ~= isActive then
                bind.active = isActive
                if bind.callback then bind.callback(isActive) end
            end
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x 
       and m.y >= pos.y and m.y <= pos.y + size.y
end

-- [ 3 ] HUD Functions
function RCM:DrawWatermark()
    if not self.State.Watermark.Visible then return end
    local pos = self.State.Watermark.Pos
    local text = "Severe UI | FPS: " .. tostring(self.State.CurrentFPS)
    local width = (7 * #text) + 20
    local size = vector.create(width, 22, 0)
    
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, size) then
            self.State.Watermark.Dragging = true
            self.State.Watermark.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.Watermark.Dragging then
            self.State.Watermark.Pos = vector.create(self.State.MousePos.x - self.State.Watermark.Offset.x, self.State.MousePos.y - self.State.Watermark.Offset.y, 0)
            pos = self.State.Watermark.Pos
        end
    end

    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(size.x - 2, size.y - 2, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(width, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + 10, pos.y + 4, 0), text, self.Theme.Text)
end

function RCM:DrawKeybindList()
    if not self.State.KeybindList.Visible then return end
    
    -- Filter items based on mode
    local itemsToShow = {}
    for _, bind in ipairs(RCM.Binders) do
        if self.State.KeybindList.Mode == "Always" then
            table.insert(itemsToShow, bind)
        elseif self.State.KeybindList.Mode == "Active" and bind.active then
            table.insert(itemsToShow, bind)
        end
    end
    
    -- Don't draw if empty in "Active" mode, unless dragging enabled
    if #itemsToShow == 0 and not self.State.Enabled then return end

    local pos = self.State.KeybindList.Pos
    local width = 150
    local headerHeight = 22
    local itemHeight = 18
    local totalHeight = headerHeight + (#itemsToShow * itemHeight) + 5
    local size = vector.create(width, totalHeight, 0)

    -- Drag Logic
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        -- Allow dragging header
        if click and self:IsMouseOver(pos, vector.create(width, headerHeight, 0)) then
            self.State.KeybindList.Dragging = true
            self.State.KeybindList.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.KeybindList.Dragging then
            self.State.KeybindList.Pos = vector.create(self.State.MousePos.x - self.State.KeybindList.Offset.x, self.State.MousePos.y - self.State.KeybindList.Offset.y, 0)
            pos = self.State.KeybindList.Pos
        end
    end

    -- Draw Container
    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(width - 2, totalHeight - 2, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(width, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + (width/2) - 25, pos.y + 4, 0), "Keybinds", self.Theme.Text)
    
    -- Draw Items
    local cy = pos.y + headerHeight + 2
    for _, bind in ipairs(itemsToShow) do
        local col = bind.active and self.Theme.Accent or self.Theme.TextDim
        local txt = string.format("[%s] %s", bind.key, bind.name)
        RCM.Label(vector.create(pos.x + 10, cy, 0), txt, col)
        cy = cy + itemHeight
    end
end

-- [ 4 ] Library Core
function Library:Window(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end

    local window = {
        name = props.Name or "Severe UI",
        pos = props.Position or vector.create(100, 100, 0),
        size = vector.create(280, 0, 0),
        dragging = false,
        dragOffset = vector.create(0,0,0),
        pages = {},
        activePage = 1
    }

    function window:Draw()
        if not RCM.State.Enabled then return end

        local x, y = self.pos.x, self.pos.y
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld

        if click and RCM:IsMouseOver(self.pos, vector.create(280, 25, 0)) then
            self.dragging = true
            self.dragOffset = vector.create(RCM.State.MousePos.x - x, RCM.State.MousePos.y - y, 0)
        end

        if self.dragging then
            if RCM.State.MouseDown then
                self.pos = vector.create(RCM.State.MousePos.x - self.dragOffset.x, RCM.State.MousePos.y - self.dragOffset.y, 0)
            else
                self.dragging = false
            end
        end

        -- Header & Tabs
        local tabXCursor = 10
        local tabYOffset = 25
        local tabRowHeight = 18
        
        for i, page in ipairs(self.pages) do
            local label = page.name
            local textWidth = (7 * #label) + 15 
            if (tabXCursor + textWidth) > 270 then
                tabXCursor = 10
                tabYOffset = tabYOffset + tabRowHeight
            end
            tabXCursor = tabXCursor + textWidth
        end
        local headerHeight = tabYOffset + 20 

        -- Content
        local currentPage = self.pages[self.activePage]
        local contentHeight = 0

        if currentPage then
            for _, section in ipairs(currentPage.sections) do
                contentHeight = contentHeight + 20
                for _, item in ipairs(section.items) do
                    contentHeight = contentHeight + 18
                    if item.type == "dropdown" and item.open then
                        contentHeight = contentHeight + (#item.options * 18)
                    end
                end
                contentHeight = contentHeight + 5
            end
        end
        
        local totalHeight = headerHeight + contentHeight + 5
        self.size = vector.create(280, totalHeight, 0)

        -- Draw Body
        RCM.Rect(self.pos, self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x + 1, y + 1, 0), vector.create(278, totalHeight - 2, 0), RCM.Theme.Background, 1)
        RCM.Rect(self.pos, vector.create(280, 2, 0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x + 10, y + 5, 0), self.name, RCM.Theme.Text)
        
        -- Draw Tabs
        tabXCursor = 10
        tabYOffset = 25
        
        for i, page in ipairs(self.pages) do
            local isActive = (self.activePage == i)
            local label = page.name
            local textWidth = (7 * #label) + 10
            
            if (tabXCursor + textWidth + 5) > 270 then
                tabXCursor = 10
                tabYOffset = tabYOffset + tabRowHeight
            end
            
            local tabPos = vector.create(x + tabXCursor, y + tabYOffset, 0)
            local tabSize = vector.create(textWidth, 16, 0)
            local isHover = RCM:IsMouseOver(tabPos, tabSize)
            
            if isHover and click then self.activePage = i end
            
            local textColor = isActive and RCM.Theme.Accent or RCM.Theme.TextDim
            if isHover then textColor = RCM.Theme.Text end
            
            RCM.Label(tabPos, label, textColor)
            if isActive then
                RCM.Rect(vector.create(x + tabXCursor, y + tabYOffset + 14, 0), vector.create(textWidth, 1, 0), RCM.Theme.Accent, 1)
            end
            tabXCursor = tabXCursor + textWidth + 5
        end
        
        RCM.Rect(vector.create(x + 5, y + headerHeight - 2, 0), vector.create(270, 1, 0), RCM.Theme.Hover, 1)

        -- Draw Content
        local contentY = y + headerHeight
        
        if currentPage then
            for _, section in ipairs(currentPage.sections) do
                RCM.Label(vector.create(x + 10, contentY + 3, 0), "[" .. section.name .. "]", RCM.Theme.Section)
                contentY = contentY + 20

                for _, item in ipairs(section.items) do
                    local itemPos = vector.create(x + 15, contentY, 0)
                    local itemSize = vector.create(250, 16, 0)
                    local hovered = RCM:IsMouseOver(itemPos, itemSize)
                    local itemClick = hovered and click

                    if hovered then RCM.Rect(itemPos, itemSize, RCM.Theme.Hover, 0.5) end

                    local displayName = item.name
                    local nameX = x + 20

                    if item.type == "toggle" then
                        if itemClick then 
                            item.value = not item.value 
                            item.callback(item.value)
                        end
                        local status = item.value and "[ON]" or "[OFF]"
                        local col = item.value and RCM.Theme.Accent or RCM.Theme.Text
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        RCM.Label(vector.create(x + 240, contentY + 2, 0), status, col, true)

                    elseif item.type == "button" then
                        if itemClick then item.callback() end
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, hovered and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "slider" then
                        if hovered and isleftpressed() then
                            local relX = RCM.State.MousePos.x - (x + 150)
                            local percent = math.clamp(relX / 100, 0, 1)
                            local newVal = math.floor(item.min + (item.max - item.min) * percent)
                            if newVal ~= item.value then
                                item.value = newVal
                                item.callback(newVal)
                            end
                        end
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        local barX = x + 150
                        RCM.Rect(vector.create(barX, contentY + 6, 0), vector.create(100, 4, 0), RCM.Theme.Section, 1)
                        local fillW = ((item.value - item.min) / (item.max - item.min)) * 100
                        RCM.Rect(vector.create(barX, contentY + 6, 0), vector.create(fillW, 4, 0), RCM.Theme.Accent, 1)
                        RCM.Label(vector.create(barX + 110, contentY + 2, 0), tostring(item.value), RCM.Theme.Text)

                    elseif item.type == "dropdown" then
                        if itemClick then item.open = not item.open end
                        local icon = item.open and "[-]" or "[+]"
                        displayName = item.name .. ": " .. item.selected
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        RCM.Label(vector.create(x + 250, contentY + 2, 0), icon, RCM.Theme.Section, true)
                        if item.open then
                            local dropY = contentY + 18
                            for _, opt in ipairs(item.options) do
                                local optPos = vector.create(x + 30, dropY, 0)
                                local optSize = vector.create(230, 16, 0)
                                if RCM:IsMouseOver(optPos, optSize) then
                                    RCM.Rect(optPos, optSize, RCM.Theme.Hover, 0.5)
                                    if click then
                                        item.selected = opt
                                        item.open = false
                                        item.callback(opt)
                                    end
                                end
                                local optCol = (item.selected == opt) and RCM.Theme.Accent or RCM.Theme.Text
                                RCM.Label(vector.create(x + 35, dropY + 2, 0), opt, optCol)
                                dropY = dropY + 18
                            end
                            contentY = contentY + (#item.options * 18)
                        end

                    -- [ FEATURE ] Keybind Binder
                    elseif item.type == "binder" then
                        if itemClick then item.listening = not item.listening end
                        
                        local bindText = item.key
                        if item.listening then bindText = "..." end
                        
                        local txt = item.name .. ": [" .. bindText .. "]"
                        local col = item.listening and RCM.Theme.Accent or RCM.Theme.Text
                        
                        RCM.Label(vector.create(nameX, contentY + 2, 0), txt, col)
                    end

                    if item.tooltip then
                        local iconPos = vector.create(x + 260, contentY + 2, 0)
                        RCM.Label(iconPos, "(?)", RCM.Theme.Section)
                        if RCM:IsMouseOver(iconPos, vector.create(15, 13, 0)) then
                            RCM.State.ActiveTooltip = item.tooltip
                        end
                    end

                    contentY = contentY + 18
                end
                contentY = contentY + 5
            end
        end
    end

    function window:Page(props)
        local page = { name = props.Name or "Page", sections = {} }
        function page:Section(props)
            local section = { name = props.Name or "Section", items = {} }
            function section:Toggle(p) table.insert(section.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback or function()end, tooltip=p.Tooltip}) end
            function section:Slider(p) table.insert(section.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback or function()end, tooltip=p.Tooltip}) end
            function section:Button(p) table.insert(section.items, {type="button", name=p.Name, callback=p.Callback or function()end, tooltip=p.Tooltip}) end
            function section:Dropdown(p) table.insert(section.items, {type="dropdown", name=p.Name, options=p.Options, selected=p.Default or p.Options[1], open=false, callback=p.Callback or function()end, tooltip=p.Tooltip}) end
            
            -- [ NEW ] Binder Component
            function section:Binder(p) 
                local bind = {
                    type="binder", 
                    name=p.Name, 
                    key=p.Default or "None", 
                    active=false, 
                    listening=false, 
                    callback=p.Callback or function()end, 
                    tooltip=p.Tooltip
                }
                table.insert(section.items, bind)
                table.insert(RCM.Binders, bind) -- Add to global registry
            end
            
            table.insert(page.sections, section)
            return section
        end
        table.insert(self.pages, page)
        return page
    end

    return window
end

function RCM:Init()
    local renderEvent = RunService.Render or game:GetService("RunService").RenderStepped
    renderEvent:Connect(function()
        self:UpdateInput()
        self:UpdateBinders() -- [ NEW ] Check logic every frame
        self.State.ActiveTooltip = nil
        
        self:DrawWatermark()
        self:DrawKeybindList() -- [ NEW ] Draw Keybind HUD

        for _, win in ipairs(self.Windows) do
            win:Draw()
        end
        
        if self.State.ActiveTooltip then
            local t = self.State.ActiveTooltip
            local mp = self.State.MousePos
            local w = (8*#t)+12
            local tx, ty = mp.x+12, mp.y+12
            if (tx+w)>self.State.ScreenSize.x then tx=self.State.ScreenSize.x-w-5 end
            RCM.Rect(vector.create(tx,ty,1), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(tx+1,ty+1,1), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(tx+5,ty+3,1), t, RCM.Theme.Text)
        end
    end)
end

RCM.Windows = {}
function RCM:CreateWindow(props)
    local win = Library:Window(props)
    table.insert(self.Windows, win)
    return win
end

RCM:Init()

return RCM
