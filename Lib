--!optimization 2
-- [ RCM ] Severe UI Library v3.1
-- Features: Dynamic HUD Width, Increased Padding, Keybind Binders, Config System

local RCM = {}
local Library = {}

-- [ 1 ] Configuration
RCM.Theme = {
    Background = Color3.new(0.104, 0.104, 0.104),
    Border     = Color3.new(0.023, 0.023, 0.023),
    Accent     = Color3.new(0.8039, 0.0, 0.4980),
    Text       = Color3.new(1, 1, 1),
    TextDim    = Color3.new(0.5, 0.5, 0.5),
    Section    = Color3.new(0.588, 0.588, 0.588),
    Hover      = Color3.new(0.2, 0.2, 0.2),
    TooltipBg  = Color3.new(0.05, 0.05, 0.05)
}

-- [ Constants for Spacing ]
local PAD_X = 25       -- Horizontal padding for items
local ITEM_H = 24      -- Vertical spacing per item (Previously 18)
local SEC_PAD = 28     -- Spacing between sections (Previously 20)

RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false,
    MouseHeld = false,
    ToggleKey = "Delete",
    LastToggle = 0,
    ActiveTooltip = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    
    -- FPS State
    LastTick = 0, FrameCount = 0, CurrentFPS = 60,

    -- HUD States
    Watermark = { Visible = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) }
}

RCM.Binders = {} 

-- [ 2 ] Helpers
function RCM.Rect(pos, size, color, alpha)
    DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1)
end

function RCM.Label(pos, text, color, center)
    DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy")
end

function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local currentDown = isleftpressed()
    if currentDown and not self.State.MouseDown then
        self.State.MouseDown = true
    elseif currentDown and self.State.MouseDown then
        self.State.MouseHeld = true
    elseif not currentDown then
        self.State.MouseDown = false
        self.State.MouseHeld = false
        self.State.Watermark.Dragging = false
        self.State.KeybindList.Dragging = false
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then
        for _, k in ipairs(keys) do
            if k == self.State.ToggleKey then isTogglePressed = true break end
        end
    end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled
        self.State.LastToggle = tick()
    end

    -- FPS Logic
    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount
        self.State.FrameCount = 0
        self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end

    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" then
                    bind.key = k
                    bind.listening = false
                end
            end
        else
            local isActive = keyMap[bind.key] == true
            if bind.active ~= isActive then
                bind.active = isActive
                if bind.callback then bind.callback(isActive) end
            end
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x 
       and m.y >= pos.y and m.y <= pos.y + size.y
end

-- [ 3 ] HUD Functions
function RCM:DrawWatermark()
    if not self.State.Watermark.Visible then return end
    local pos = self.State.Watermark.Pos
    local text = "Severe UI | FPS: " .. tostring(self.State.CurrentFPS)
    local width = (7 * #text) + 30 -- Increased padding
    local size = vector.create(width, 24, 0)
    
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, size) then
            self.State.Watermark.Dragging = true
            self.State.Watermark.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.Watermark.Dragging then
            self.State.Watermark.Pos = vector.create(self.State.MousePos.x - self.State.Watermark.Offset.x, self.State.MousePos.y - self.State.Watermark.Offset.y, 0)
            pos = self.State.Watermark.Pos
        end
    end

    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(size.x - 2, size.y - 2, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(width, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + 15, pos.y + 5, 0), text, self.Theme.Text)
end

function RCM:DrawKeybindList()
    if not self.State.KeybindList.Visible then return end
    
    local itemsToShow = {}
    for _, bind in ipairs(RCM.Binders) do
        if self.State.KeybindList.Mode == "Always" then
            table.insert(itemsToShow, bind)
        elseif self.State.KeybindList.Mode == "Active" and bind.active then
            table.insert(itemsToShow, bind)
        end
    end
    
    if #itemsToShow == 0 and not self.State.Enabled then return end

    -- [ FIX ] Calculate dynamic width based on longest text
    local maxWidth = 150
    for _, bind in ipairs(itemsToShow) do
        local txt = string.format("[%s] %s", bind.key, bind.name)
        local w = (7 * #txt) + 30 -- Text width + Padding
        if w > maxWidth then maxWidth = w end
    end

    local pos = self.State.KeybindList.Pos
    local width = maxWidth
    local headerHeight = 24
    local itemHeight = 20
    local totalHeight = headerHeight + (#itemsToShow * itemHeight) + 5
    local size = vector.create(width, totalHeight, 0)

    -- Drag Logic
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, vector.create(width, headerHeight, 0)) then
            self.State.KeybindList.Dragging = true
            self.State.KeybindList.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.KeybindList.Dragging then
            self.State.KeybindList.Pos = vector.create(self.State.MousePos.x - self.State.KeybindList.Offset.x, self.State.MousePos.y - self.State.KeybindList.Offset.y, 0)
            pos = self.State.KeybindList.Pos
        end
    end

    -- Draw Container
    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(width - 2, totalHeight - 2, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(width, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + (width/2) - 25, pos.y + 5, 0), "Keybinds", self.Theme.Text)
    
    -- Draw Items
    local cy = pos.y + headerHeight + 2
    for _, bind in ipairs(itemsToShow) do
        local col = bind.active and self.Theme.Accent or self.Theme.TextDim
        local txt = string.format("[%s] %s", bind.key, bind.name)
        RCM.Label(vector.create(pos.x + 10, cy, 0), txt, col)
        cy = cy + itemHeight
    end
end

-- [ 4 ] Library Core
function Library:Window(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end

    local window = {
        name = props.Name or "Severe UI",
        pos = props.Position or vector.create(100, 100, 0),
        size = vector.create(280, 0, 0),
        dragging = false,
        dragOffset = vector.create(0,0,0),
        pages = {},
        activePage = 1
    }

    function window:Draw()
        if not RCM.State.Enabled then return end

        local x, y = self.pos.x, self.pos.y
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld

        if click and RCM:IsMouseOver(self.pos, vector.create(280, 25, 0)) then
            self.dragging = true
            self.dragOffset = vector.create(RCM.State.MousePos.x - x, RCM.State.MousePos.y - y, 0)
        end

        if self.dragging then
            if RCM.State.MouseDown then
                self.pos = vector.create(RCM.State.MousePos.x - self.dragOffset.x, RCM.State.MousePos.y - self.dragOffset.y, 0)
            else
                self.dragging = false
            end
        end

        -- Header & Tabs
        local tabXCursor = 10
        local tabYOffset = 25
        local tabRowHeight = 18
        
        for i, page in ipairs(self.pages) do
            local label = page.name
            local textWidth = (7 * #label) + 15 
            if (tabXCursor + textWidth) > 270 then
                tabXCursor = 10
                tabYOffset = tabYOffset + tabRowHeight
            end
            tabXCursor = tabXCursor + textWidth
        end
        local headerHeight = tabYOffset + 20 

        -- Content Height Calc
        local currentPage = self.pages[self.activePage]
        local contentHeight = 0

        if currentPage then
            for _, section in ipairs(currentPage.sections) do
                contentHeight = contentHeight + SEC_PAD -- Increased Section Spacing
                for _, item in ipairs(section.items) do
                    contentHeight = contentHeight + ITEM_H -- Increased Item Spacing
                    if item.type == "dropdown" and item.open then
                        contentHeight = contentHeight + (#item.options * ITEM_H)
                    elseif item.type == "colorpicker" and item.open then
                        contentHeight = contentHeight + (3 * ITEM_H) + 5
                    end
                end
                contentHeight = contentHeight + 5
            end
        end
        
        local totalHeight = headerHeight + contentHeight + 5
        self.size = vector.create(280, totalHeight, 0)

        -- Draw Body
        RCM.Rect(self.pos, self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x + 1, y + 1, 0), vector.create(278, totalHeight - 2, 0), RCM.Theme.Background, 1)
        RCM.Rect(self.pos, vector.create(280, 2, 0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x + 10, y + 5, 0), self.name, RCM.Theme.Text)
        
        -- Draw Tabs
        tabXCursor = 10
        tabYOffset = 25
        
        for i, page in ipairs(self.pages) do
            local isActive = (self.activePage == i)
            local label = page.name
            local textWidth = (7 * #label) + 10
            
            if (tabXCursor + textWidth + 5) > 270 then
                tabXCursor = 10
                tabYOffset = tabYOffset + tabRowHeight
            end
            
            local tabPos = vector.create(x + tabXCursor, y + tabYOffset, 0)
            local tabSize = vector.create(textWidth, 16, 0)
            local isHover = RCM:IsMouseOver(tabPos, tabSize)
            
            if isHover and click then self.activePage = i end
            
            local textColor = isActive and RCM.Theme.Accent or RCM.Theme.TextDim
            if isHover then textColor = RCM.Theme.Text end
            
            RCM.Label(tabPos, label, textColor)
            if isActive then
                RCM.Rect(vector.create(x + tabXCursor, y + tabYOffset + 14, 0), vector.create(textWidth, 1, 0), RCM.Theme.Accent, 1)
            end
            tabXCursor = tabXCursor + textWidth + 5
        end
        
        RCM.Rect(vector.create(x + 5, y + headerHeight - 2, 0), vector.create(270, 1, 0), RCM.Theme.Hover, 1)

        -- Draw Content
        local contentY = y + headerHeight
        
        if currentPage then
            for _, section in ipairs(currentPage.sections) do
                -- Section Header Spacing
                RCM.Label(vector.create(x + 10, contentY + 5, 0), "[" .. section.name .. "]", RCM.Theme.Section)
                contentY = contentY + SEC_PAD

                for _, item in ipairs(section.items) do
                    local itemPos = vector.create(x + 15, contentY, 0)
                    local itemSize = vector.create(250, 18, 0) -- Taller hover area
                    local hovered = RCM:IsMouseOver(itemPos, itemSize)
                    local itemClick = hovered and click

                    if hovered then RCM.Rect(itemPos, itemSize, RCM.Theme.Hover, 0.5) end

                    local displayName = item.name
                    local nameX = x + PAD_X -- Increased Padding (25px)

                    if item.type == "toggle" then
                        if itemClick then 
                            item.value = not item.value 
                            item.callback(item.value)
                        end
                        local status = item.value and "[ON]" or "[OFF]"
                        local col = item.value and RCM.Theme.Accent or RCM.Theme.Text
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        RCM.Label(vector.create(x + 240, contentY + 2, 0), status, col, true)

                    elseif item.type == "button" then
                        if itemClick then item.callback() end
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, hovered and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "slider" then
                        if hovered and isleftpressed() then
                            local relX = RCM.State.MousePos.x - (x + 150)
                            local percent = math.clamp(relX / 100, 0, 1)
                            local newVal = math.floor(item.min + (item.max - item.min) * percent)
                            if newVal ~= item.value then
                                item.value = newVal
                                item.callback(newVal)
                            end
                        end
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        local barX = x + 150
                        RCM.Rect(vector.create(barX, contentY + 6, 0), vector.create(100, 4, 0), RCM.Theme.Section, 1)
                        local fillW = ((item.value - item.min) / (item.max - item.min)) * 100
                        RCM.Rect(vector.create(barX, contentY + 6, 0), vector.create(fillW, 4, 0), RCM.Theme.Accent, 1)
                        RCM.Label(vector.create(barX + 110, contentY + 2, 0), tostring(item.value), RCM.Theme.Text)

                    elseif item.type == "dropdown" then
                        if itemClick then item.open = not item.open end
                        local icon = item.open and "[-]" or "[+]"
                        displayName = item.name .. ": " .. item.selected
                        RCM.Label(vector.create(nameX, contentY + 2, 0), displayName, RCM.Theme.Text)
                        RCM.Label(vector.create(x + 250, contentY + 2, 0), icon, RCM.Theme.Section, true)
                        
                        if item.open then
                            local dropY = contentY + ITEM_H
                            for _, opt in ipairs(item.options) do
                                local optPos = vector.create(x + 30, dropY, 0)
                                local optSize = vector.create(230, 18, 0)
                                if RCM:IsMouseOver(optPos, optSize) then
                                    RCM.Rect(optPos, optSize, RCM.Theme.Hover, 0.5)
                                    if click then
                                        item.selected = opt
                                        item.open = false
                                        item.callback(opt)
                                    end
                                end
                                local optCol = (item.selected == opt) and RCM.Theme.Accent or RCM.Theme.Text
                                RCM.Label(vector.create(x + 35, dropY + 2, 0), opt, optCol)
                                dropY = dropY + ITEM_H
                            end
                            contentY = contentY + (#item.options * ITEM_H)
                        end

                    elseif item.type == "binder" then
                        if itemClick then item.listening = not item.listening end
                        
                        local bindText = item.key
                        if item.listening then bindText = "..." end
                        
                        local txt = item.name .. ": [" .. bindText .. "]"
                        local col = item.listening and RCM.Theme.Accent or RCM.Theme.Text
                        
                        RCM.Label(vector.create(nameX, contentY + 2, 0), txt, col)

                    elseif item.type == "colorpicker" then
                        if itemClick then item.open = not item.open end
                        RCM.Label(vector.create(nameX, contentY + 2, 0), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(x + 230, contentY + 2, 0), vector.create(20, 12, 0), item.color, 1)
                        
                        if item.open then
                            local cpY = contentY + ITEM_H
                            local function drawCSlider(lbl, val, max, col)
                                local sHover = RCM:IsMouseOver(vector.create(x + 30, cpY, 0), vector.create(230, 16, 0))
                                if sHover and isleftpressed() then
                                    val = math.floor(math.clamp((RCM.State.MousePos.x - (x + 80)) / 150, 0, 1) * max)
                                end
                                RCM.Label(vector.create(x + 35, cpY + 2, 0), lbl, col)
                                RCM.Rect(vector.create(x + 80, cpY + 6, 0), vector.create(150, 4, 0), RCM.Theme.Section, 1)
                                RCM.Rect(vector.create(x + 80, cpY + 6, 0), vector.create((val/max)*150, 4, 0), col, 1)
                                return val
                            end
                            
                            local r = drawCSlider("R", math.floor(item.color.R * 255), 255, Color3.new(1,0,0)); cpY = cpY + ITEM_H
                            local g = drawCSlider("G", math.floor(item.color.G * 255), 255, Color3.new(0,1,0)); cpY = cpY + ITEM_H
                            local b = drawCSlider("B", math.floor(item.color.B * 255), 255, Color3.new(0,0,1))
                            
                            local newCol = Color3.fromRGB(r, g, b)
                            if newCol ~= item.color then item.color = newCol; item.callback(newCol) end
                            
                            contentY = contentY + (3 * ITEM_H) + 5
                        end
                    end

                    if item.tooltip then
                        local iconPos = vector.create(x + 260, contentY + 2, 0)
                        RCM.Label(iconPos, "(?)", RCM.Theme.Section)
                        if RCM:IsMouseOver(iconPos, vector.create(15, 13, 0)) then
                            RCM.State.ActiveTooltip = item.tooltip
                        end
                    end

                    contentY = contentY + ITEM_H
                end
                contentY = contentY + 5
            end
        end
    end

    function window:Page(props)
        local page = { name = props.Name, sections = {} }
        function page:Section(props)
            local section = { name = props.Name, items = {} }
            function section:Toggle(p) table.insert(section.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Slider(p) table.insert(section.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Button(p) table.insert(section.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Dropdown(p) table.insert(section.items, {type="dropdown", name=p.Name, options=p.Options, selected=p.Default, open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            
            function section:Binder(p) 
                local bind = {
                    type="binder", name=p.Name, key=p.Default or "None", active=false, listening=false, callback=p.Callback, tooltip=p.Tooltip
                }
                table.insert(section.items, bind)
                table.insert(RCM.Binders, bind)
            end
            
            function section:ColorPicker(p) table.insert(section.items, {type="colorpicker", name=p.Name, color=p.Default or Color3.new(1,1,1), open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            table.insert(page.sections, section)
            return section
        end
        table.insert(self.pages, page)
        return page
    end
    return window
end

function Library:SaveConfig(name)
    local data = {}
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if item.type == "toggle" then data[item.name] = item.value
                    elseif item.type == "slider" then data[item.name] = item.value
                    elseif item.type == "dropdown" then data[item.name] = item.selected
                    elseif item.type == "binder" then data[item.name] = item.key
                    elseif item.type == "colorpicker" then data[item.name] = {R=item.color.R, G=item.color.G, B=item.color.B} end
                end
            end
        end
    end
    writefile(name .. ".json", crypt.json.encode(data))
end

function Library:LoadConfig(name)
    if not isfile(name .. ".json") then return end
    local data = crypt.json.decode(readfile(name .. ".json"))
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if data[item.name] ~= nil then
                        if item.type == "toggle" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "slider" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "dropdown" then item.selected = data[item.name]; if item.callback then item.callback(item.selected) end
                        elseif item.type == "binder" then item.key = data[item.name]; if item.callback then item.callback(item.key) end
                        elseif item.type == "colorpicker" then 
                            local c = data[item.name]; item.color = Color3.new(c.R, c.G, c.B); if item.callback then item.callback(item.color) end 
                        end
                    end
                end
            end
        end
    end
end

function RCM:Init()
    local renderEvent = nil
    if RunService and RunService.Render then renderEvent = RunService.Render
    elseif game then renderEvent = game:GetService("RunService").RenderStepped end
    
    if not renderEvent then return warn("No Render event found") end
    
    local function Connect(event, cb)
        local s, res = pcall(function() return event:Connect(cb) end)
        if s then return res end
        s, res = pcall(function() return event:connect(cb) end)
        if s then return res end
        warn("Failed to connect to Render event")
    end

    Connect(renderEvent, function()
        self:UpdateInput()
        self:UpdateBinders()
        self.State.ActiveTooltip = nil
        
        self:DrawWatermark()
        self:DrawKeybindList()

        for _, win in ipairs(self.Windows) do win:Draw() end
        
        if self.State.ActiveTooltip then
            local t = self.State.ActiveTooltip
            local mp = self.State.MousePos
            local w = (8*#t)+12
            local tx, ty = mp.x+12, mp.y+12
            if (tx+w)>self.State.ScreenSize.x then tx=self.State.ScreenSize.x-w-5 end
            if (ty+20)>self.State.ScreenSize.y then ty=self.State.ScreenSize.y-25 end
            RCM.Rect(vector.create(tx,ty,1), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(tx+1,ty+1,1), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(tx+5,ty+3,1), t, RCM.Theme.Text)
        end
    end)
end

RCM.Windows = {}
function RCM:CreateWindow(props)
    local win = Library:Window(props)
    table.insert(self.Windows, win)
    return win
end

RCM:Init()
return RCM
