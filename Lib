--!optimization 2
-- [ RCM ] Severe UI Library v4.0 (Pro Layout)
-- Features: Dual Columns (Left/Right), Dynamic Tooltips, Wide Menu, Config System

local RCM = {}
local Library = {}

-- [ 1 ] Configuration & Theme
RCM.Theme = {
    Background = Color3.new(0.08, 0.08, 0.08),      -- Main Window Bg
    SectionBg  = Color3.new(0.12, 0.12, 0.12),      -- Section Box Bg
    Border     = Color3.new(0.0, 0.0, 0.0),         -- Black Outline
    Accent     = Color3.new(0.8039, 0.0, 0.4980),   -- Main Accent
    Text       = Color3.new(0.9, 0.9, 0.9),         -- Main Text
    TextDim    = Color3.new(0.5, 0.5, 0.5),         -- Inactive Text
    Hover      = Color3.new(0.16, 0.16, 0.16),      -- Item Hover
    TooltipBg  = Color3.new(0.05, 0.05, 0.05)       -- Tooltip Bg
}

-- Layout Constants
local WIN_W = 550
local COL_W = 260
local COL_GAP = 10
local TAB_H = 25
local SEC_PAD = 10

RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false,
    MouseHeld = false,
    ToggleKey = "Delete",
    LastToggle = 0,
    ActiveTooltip = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    
    Watermark = { Visible = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) },
    
    -- FPS State
    LastTick = 0, FrameCount = 0, CurrentFPS = 60
}

RCM.Binders = {} 

-- [ 2 ] Helpers
function RCM.Rect(pos, size, color, alpha)
    DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1)
end

function RCM.Label(pos, text, color, center)
    DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy")
end

function RCM.Stroke(pos, size, color)
    -- DrawingImmediate doesn't have a hollow rect, so we draw 1px borders manually if needed, 
    -- but usually Border color + slightly smaller inner rect works for filled shapes.
    -- Here we just use the FilledRectangle logic with offsets in the main draw calls.
end

function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local currentDown = isleftpressed()
    if currentDown and not self.State.MouseDown then
        self.State.MouseDown = true
    elseif currentDown and self.State.MouseDown then
        self.State.MouseHeld = true
    elseif not currentDown then
        self.State.MouseDown = false
        self.State.MouseHeld = false
        self.State.Watermark.Dragging = false
        self.State.KeybindList.Dragging = false
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then
        for _, k in ipairs(keys) do
            if k == self.State.ToggleKey then isTogglePressed = true break end
        end
    end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled
        self.State.LastToggle = tick()
    end

    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount
        self.State.FrameCount = 0
        self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end

    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" then
                    bind.key = k; bind.listening = false;
                    if bind.callback then bind.callback(k) end
                end
            end
        else
            local isActive = keyMap[bind.key] == true
            if bind.active ~= isActive then
                bind.active = isActive
                if bind.type == "binder" and bind.callback then bind.callback(isActive) end
            end
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x 
       and m.y >= pos.y and m.y <= pos.y + size.y
end

-- [ 3 ] HUD Functions
function RCM:DrawWatermark()
    if not self.State.Watermark.Visible then return end
    local pos = self.State.Watermark.Pos
    local text = "Severe UI | FPS: " .. tostring(self.State.CurrentFPS)
    local width = (7 * #text) + 20
    local size = vector.create(width, 22, 0)
    
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, size) then
            self.State.Watermark.Dragging = true
            self.State.Watermark.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.Watermark.Dragging then
            self.State.Watermark.Pos = vector.create(self.State.MousePos.x - self.State.Watermark.Offset.x, self.State.MousePos.y - self.State.Watermark.Offset.y, 0)
            pos = self.State.Watermark.Pos
        end
    end

    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(width - 2, 20, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(width, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + 10, pos.y + 4, 0), text, self.Theme.Text)
end

function RCM:DrawKeybindList()
    if not self.State.KeybindList.Visible then return end
    
    local itemsToShow = {}
    for _, bind in ipairs(RCM.Binders) do
        if self.State.KeybindList.Mode == "Always" then table.insert(itemsToShow, bind)
        elseif self.State.KeybindList.Mode == "Active" and bind.active then table.insert(itemsToShow, bind) end
    end
    if #itemsToShow == 0 and not self.State.Enabled then return end

    local maxWidth = 130
    for _, b in ipairs(itemsToShow) do
        local w = (7 * #b.name) + 50
        if w > maxWidth then maxWidth = w end
    end

    local pos = self.State.KeybindList.Pos
    local totalHeight = 24 + (#itemsToShow * 18) + 4
    local size = vector.create(maxWidth, totalHeight, 0)

    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, vector.create(maxWidth, 24, 0)) then
            self.State.KeybindList.Dragging = true
            self.State.KeybindList.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.KeybindList.Dragging then
            self.State.KeybindList.Pos = vector.create(self.State.MousePos.x - self.State.KeybindList.Offset.x, self.State.MousePos.y - self.State.KeybindList.Offset.y, 0)
            pos = self.State.KeybindList.Pos
        end
    end

    RCM.Rect(pos, size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, 0), vector.create(maxWidth - 2, totalHeight - 2, 0), self.Theme.Background, 1)
    RCM.Rect(pos, vector.create(maxWidth, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + (maxWidth/2) - 20, pos.y + 5, 0), "Keybinds", self.Theme.Text)
    
    local cy = pos.y + 26
    for _, bind in ipairs(itemsToShow) do
        local col = bind.active and self.Theme.Accent or self.Theme.TextDim
        RCM.Label(vector.create(pos.x + 5, cy, 0), bind.name, self.Theme.Text)
        RCM.Label(vector.create(pos.x + maxWidth - (7 * #bind.key) - 10, cy, 0), "["..bind.key.."]", col)
        cy = cy + 18
    end
end

-- [ 4 ] Library Core
function Library:Window(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end

    local window = {
        name = props.Name or "Severe UI",
        pos = props.Position or vector.create(200, 200, 0),
        size = vector.create(WIN_W, 0, 0),
        dragging = false,
        dragOffset = vector.create(0,0,0),
        pages = {},
        activePage = 1
    }

    function window:Draw()
        if not RCM.State.Enabled then return end

        local x, y = self.pos.x, self.pos.y
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld

        if click and RCM:IsMouseOver(self.pos, vector.create(WIN_W, 30, 0)) then
            self.dragging = true
            self.dragOffset = vector.create(RCM.State.MousePos.x - x, RCM.State.MousePos.y - y, 0)
        end
        if self.dragging then
            if RCM.State.MouseDown then
                self.pos = vector.create(RCM.State.MousePos.x - self.dragOffset.x, RCM.State.MousePos.y - self.dragOffset.y, 0)
            else self.dragging = false end
        end

        -- [ Logic ] Column & Height Calc
        local page = self.pages[self.activePage]
        local leftY, rightY = 55, 55 -- Start below tabs
        
        if page then
            for _, section in ipairs(page.sections) do
                -- Calc Section Height
                local h = 25 -- Header
                for _, item in ipairs(section.items) do
                    h = h + 24
                    if item.type == "dropdown" and item.open then h = h + (#item.options * 20)
                    elseif item.type == "colorpicker" and item.open then h = h + 70 end
                end
                
                -- Assign height to simulate stacking
                if section.side == "Left" then
                    section.renderY = leftY
                    leftY = leftY + h + SEC_PAD
                else
                    section.renderY = rightY
                    rightY = rightY + h + SEC_PAD
                end
            end
        end
        
        local totalH = math.max(leftY, rightY)
        self.size = vector.create(WIN_W, totalH + 10, 0)

        -- [ Draw ] Window
        RCM.Rect(self.pos, self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x + 1, y + 1, 0), vector.create(WIN_W - 2, totalH + 8, 0), RCM.Theme.Background, 1)
        RCM.Rect(self.pos, vector.create(WIN_W, 2, 0), RCM.Theme.Accent, 1)
        
        -- Header
        RCM.Label(vector.create(x + 10, y + 5, 0), self.name, RCM.Theme.Text)
        
        -- [ Draw ] Tabs
        local tabX = 10
        local tabY = 25
        for i, pg in ipairs(self.pages) do
            local w = (7 * #pg.name) + 20
            local isAct = (self.activePage == i)
            local col = isAct and RCM.Theme.Accent or RCM.Theme.TextDim
            
            if click and RCM:IsMouseOver(vector.create(x + tabX, y + tabY, 0), vector.create(w, 20, 0)) then
                self.activePage = i
            end
            
            RCM.Label(vector.create(x + tabX + 5, y + tabY, 0), pg.name, col)
            if isAct then RCM.Rect(vector.create(x + tabX + 5, y + tabY + 15, 0), vector.create(w - 10, 1, 0), RCM.Theme.Accent, 1) end
            
            tabX = tabX + w
        end
        RCM.Rect(vector.create(x + 10, y + 45, 0), vector.create(WIN_W - 20, 1, 0), RCM.Theme.Section, 1)

        -- [ Draw ] Sections
        if page then
            for _, section in ipairs(page.sections) do
                local sx = (section.side == "Left") and (x + 12) or (x + 12 + COL_W + COL_GAP)
                local sy = y + section.renderY
                
                -- Calculate actual height again for the background box
                local sh = 25
                for _, item in ipairs(section.items) do
                    sh = sh + 24
                    if item.type == "dropdown" and item.open then sh = sh + (#item.options * 20)
                    elseif item.type == "colorpicker" and item.open then sh = sh + 70 end
                end
                
                -- Section Box
                RCM.Rect(vector.create(sx, sy, 0), vector.create(COL_W, sh, 0), RCM.Theme.Border, 1)
                RCM.Rect(vector.create(sx + 1, sy + 1, 0), vector.create(COL_W - 2, sh - 2, 0), RCM.Theme.SectionBg, 1)
                RCM.Rect(vector.create(sx, sy, 0), vector.create(COL_W, 2, 0), RCM.Theme.Accent, 1)
                RCM.Label(vector.create(sx + 8, sy + 5, 0), section.name, RCM.Theme.Text)
                
                local cy = sy + 25
                for _, item in ipairs(section.items) do
                    local iH = 24
                    local itemPos = vector.create(sx + 5, cy, 0)
                    local hover = RCM:IsMouseOver(itemPos, vector.create(COL_W - 10, 20, 0))
                    local iClick = hover and click
                    if hover then RCM.Rect(itemPos, vector.create(COL_W - 10, 20, 0), RCM.Theme.Hover, 0.5) end
                    
                    local nameX = sx + 10
                    local valX  = sx + COL_W - 15
                    
                    -- Render Logic
                    if item.type == "toggle" then
                        if iClick then item.value = not item.value; item.callback(item.value) end
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, RCM.Theme.Text)
                        
                        -- Draw Box
                        local boxCol = item.value and RCM.Theme.Accent or RCM.Theme.Section
                        RCM.Rect(vector.create(valX - 10, cy + 5, 0), vector.create(10, 10, 0), RCM.Theme.Border, 1)
                        RCM.Rect(vector.create(valX - 9, cy + 6, 0), vector.create(8, 8, 0), boxCol, 1)

                    elseif item.type == "button" then
                        if iClick then item.callback() end
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, hover and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "slider" then
                        if hover and isleftpressed() then
                            local pct = math.clamp((RCM.State.MousePos.x - (valX - 100)) / 100, 0, 1)
                            local nv = math.floor(item.min + (item.max - item.min) * pct)
                            if nv ~= item.value then item.value = nv; item.callback(nv) end
                        end
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - 120, cy + 3, 0), tostring(item.value), RCM.Theme.Text)
                        
                        RCM.Rect(vector.create(valX - 100, cy + 8, 0), vector.create(100, 4, 0), RCM.Theme.Background, 1)
                        local fill = ((item.value - item.min) / (item.max - item.min)) * 100
                        RCM.Rect(vector.create(valX - 100, cy + 8, 0), vector.create(fill, 4, 0), RCM.Theme.Accent, 1)

                    elseif item.type == "dropdown" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - (7*#item.selected), cy + 3, 0), item.selected, RCM.Theme.Accent)
                        
                        if item.open then
                            local dy = cy + 24
                            for _, opt in ipairs(item.options) do
                                local oPos = vector.create(sx + 15, dy, 0)
                                if RCM:IsMouseOver(oPos, vector.create(COL_W - 30, 18, 0)) then
                                    RCM.Rect(oPos, vector.create(COL_W - 30, 18, 0), RCM.Theme.Hover, 0.5)
                                    if click then item.selected = opt; item.open = false; item.callback(opt) end
                                end
                                RCM.Label(vector.create(sx + 20, dy + 2, 0), opt, (item.selected == opt) and RCM.Theme.Accent or RCM.Theme.Text)
                                dy = dy + 20
                            end
                            iH = iH + (#item.options * 20)
                        end

                    elseif item.type == "binder" then
                        if iClick then item.listening = not item.listening end
                        local txt = "[" .. (item.listening and "..." or item.key) .. "]"
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - (7*#txt), cy + 3, 0), txt, item.listening and RCM.Theme.Accent or RCM.Theme.TextDim)

                    elseif item.type == "colorpicker" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(nameX, cy + 3, 0), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 15, cy + 5, 0), vector.create(20, 10, 0), item.color, 1)
                        
                        if item.open then
                            local py = cy + 24
                            local function slider(c, v, m)
                                if RCM:IsMouseOver(vector.create(sx+15, py, 0), vector.create(COL_W-30, 15, 0)) and isleftpressed() then
                                    local p = math.clamp((RCM.State.MousePos.x - (sx+40)) / 150, 0, 1)
                                    v = math.floor(p * m)
                                end
                                RCM.Label(vector.create(sx+20, py, 0), c, RCM.Theme.Text)
                                RCM.Rect(vector.create(sx+40, py+5, 0), vector.create(150, 4, 0), RCM.Theme.Background, 1)
                                RCM.Rect(vector.create(sx+40, py+5, 0), vector.create((v/m)*150, 4, 0), RCM.Theme.Accent, 1)
                                py = py + 20
                                return v
                            end
                            local r = slider("R", math.floor(item.color.R*255), 255)
                            local g = slider("G", math.floor(item.color.G*255), 255)
                            local b = slider("B", math.floor(item.color.B*255), 255)
                            local nc = Color3.fromRGB(r,g,b)
                            if nc ~= item.color then item.color = nc; item.callback(nc) end
                            iH = iH + 70
                        end
                    end

                    -- [ FIX ] Tooltip: Position immediately after Name text
                    if item.tooltip then
                        local nameW = (7 * #item.name)
                        local tipX = nameX + nameW + 8
                        local tipPos = vector.create(tipX, cy + 3, 0)
                        
                        RCM.Label(tipPos, "(?)", RCM.Theme.Section)
                        
                        if RCM:IsMouseOver(tipPos, vector.create(15, 13, 0)) then
                            RCM.State.ActiveTooltip = item.tooltip
                        end
                    end

                    cy = cy + iH
                end
            end
        end
    end

    function window:Page(props)
        local page = { name = props.Name, sections = {} }
        function page:Section(props)
            local section = { name = props.Name, side = props.Side or "Left", items = {} }
            function section:Toggle(p) table.insert(section.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Slider(p) table.insert(section.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Button(p) table.insert(section.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Dropdown(p) table.insert(section.items, {type="dropdown", name=p.Name, options=p.Options, selected=p.Default, open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Binder(p) 
                local b = {type="binder", name=p.Name, key=p.Default or "None", active=false, listening=false, callback=p.Callback, tooltip=p.Tooltip}
                table.insert(section.items, b); table.insert(RCM.Binders, b)
            end
            function section:ColorPicker(p) table.insert(section.items, {type="colorpicker", name=p.Name, color=p.Default or Color3.new(1,1,1), open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            table.insert(page.sections, section)
            return section
        end
        table.insert(self.pages, page)
        return page
    end
    return window
end

function Library:SaveConfig(name)
    local data = {}
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if item.type == "toggle" then data[item.name] = item.value
                    elseif item.type == "slider" then data[item.name] = item.value
                    elseif item.type == "dropdown" then data[item.name] = item.selected
                    elseif item.type == "binder" then data[item.name] = item.key
                    elseif item.type == "colorpicker" then data[item.name] = {R=item.color.R, G=item.color.G, B=item.color.B} end
                end
            end
        end
    end
    writefile(name .. ".json", crypt.json.encode(data))
end

function Library:LoadConfig(name)
    if not isfile(name .. ".json") then return end
    local data = crypt.json.decode(readfile(name .. ".json"))
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if data[item.name] ~= nil then
                        if item.type == "toggle" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "slider" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "dropdown" then item.selected = data[item.name]; if item.callback then item.callback(item.selected) end
                        elseif item.type == "binder" then item.key = data[item.name]; if item.callback then item.callback(item.key) end
                        elseif item.type == "colorpicker" then 
                            local c = data[item.name]; item.color = Color3.new(c.R, c.G, c.B); if item.callback then item.callback(item.color) end 
                        end
                    end
                end
            end
        end
    end
end

function RCM:Init()
    local renderEvent = nil
    if RunService and RunService.Render then renderEvent = RunService.Render
    elseif game then renderEvent = game:GetService("RunService").RenderStepped end
    
    if not renderEvent then return warn("No Render event found") end
    
    local function Connect(event, cb)
        local s, res = pcall(function() return event:Connect(cb) end)
        if s then return res end
        s, res = pcall(function() return event:connect(cb) end)
        if s then return res end
        warn("Failed to connect to Render event")
    end

    Connect(renderEvent, function()
        self:UpdateInput()
        self:UpdateBinders()
        self.State.ActiveTooltip = nil
        
        self:DrawWatermark()
        self:DrawKeybindList()

        for _, win in ipairs(self.Windows) do win:Draw() end
        
        if self.State.ActiveTooltip then
            local t = self.State.ActiveTooltip
            local mp = self.State.MousePos
            local w = (8*#t)+12
            local tx, ty = mp.x+12, mp.y+12
            if (tx+w)>self.State.ScreenSize.x then tx=self.State.ScreenSize.x-w-5 end
            if (ty+20)>self.State.ScreenSize.y then ty=self.State.ScreenSize.y-25 end
            RCM.Rect(vector.create(tx,ty,1), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(tx+1,ty+1,1), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(tx+5,ty+3,1), t, RCM.Theme.Text)
        end
    end)
end

RCM.Windows = {}
function RCM:CreateWindow(props)
    local win = Library:Window(props)
    table.insert(self.Windows, win)
    return win
end

RCM:Init()
return RCM
