--!optimization 2
-- [ RCM ] Severe UI Library v4.6
-- Fixed: Slider/Binder Clipping (Strict Wrapping Limits), HUD Wrapping

local RCM = {}
local Library = {}

-- [ 1 ] Configuration
RCM.Theme = {
    Background = Color3.new(0.08, 0.08, 0.08),
    SectionBg  = Color3.new(0.12, 0.12, 0.12),
    Border     = Color3.new(0.0, 0.0, 0.0),
    Accent     = Color3.new(0.8039, 0.0, 0.4980),
    Text       = Color3.new(0.9, 0.9, 0.9),
    TextDim    = Color3.new(0.5, 0.5, 0.5),
    Hover      = Color3.new(0.16, 0.16, 0.16),
    TooltipBg  = Color3.new(0.05, 0.05, 0.05)
}

RCM.Layer = { Base = 0, Section = 1, Item = 2, Text = 3, Popup = 5, Tooltip = 10 }

local WIN_W = 550
local COL_W = 260
local COL_GAP = 10
local SEC_PAD = 10

RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false,
    MouseHeld = false,
    ToggleKey = "Delete",
    LastToggle = 0,
    ActiveTooltip = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    Watermark = { Visible = true, Text = "Severe UI", Extra = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) },
    LastTick = 0, FrameCount = 0, CurrentFPS = 60
}

RCM.Binders = {} 

-- [ 2 ] Helpers
function RCM.Rect(pos, size, color, alpha)
    DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1)
end

function RCM.Label(pos, text, color, center)
    DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy")
end

-- Robust Text Wrapper
local function WrapText(str, maxChars)
    local lines = {}
    local currentLine = ""
    for word in str:gmatch("%S+") do
        if #currentLine + #word + 1 > maxChars then
            table.insert(lines, currentLine)
            currentLine = word
        else
            if currentLine == "" then currentLine = word else currentLine = currentLine .. " " .. word end
        end
    end
    if currentLine ~= "" then table.insert(lines, currentLine) end
    if #lines == 0 then lines = {str} end
    return lines
end

function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local currentDown = isleftpressed()
    if currentDown and not self.State.MouseDown then
        self.State.MouseDown = true
    elseif currentDown and self.State.MouseDown then
        self.State.MouseHeld = true
    elseif not currentDown then
        self.State.MouseDown = false
        self.State.MouseHeld = false
        self.State.Watermark.Dragging = false
        self.State.KeybindList.Dragging = false
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then
        for _, k in ipairs(keys) do
            if k == self.State.ToggleKey then isTogglePressed = true break end
        end
    end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled
        self.State.LastToggle = tick()
    end

    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount
        self.State.FrameCount = 0
        self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end

    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" then
                    bind.key = k; bind.listening = false;
                    if bind.callback then bind.callback(k) end
                end
            end
        else
            local isActive = keyMap[bind.key] == true
            if bind.active ~= isActive then
                bind.active = isActive
                if bind.type == "binder" and bind.callback then bind.callback(isActive) end
            end
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x 
       and m.y >= pos.y and m.y <= pos.y + size.y
end

function RCM:SetWatermark(text)
    self.State.Watermark.Text = text
end

-- [ 3 ] HUD Functions
function RCM:DrawWatermark()
    if not self.State.Watermark.Visible then return end
    local pos = self.State.Watermark.Pos
    local text = self.State.Watermark.Text
    if self.State.Watermark.Extra then text = text .. " | FPS: " .. tostring(self.State.CurrentFPS) end
    
    -- Wrap Watermark if absurdly long
    local lines = WrapText(text, 60)
    local width = 0
    for _, l in ipairs(lines) do
        local w = (7 * #l) + 20
        if w > width then width = w end
    end
    local height = 4 + (#lines * 18)
    
    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, vector.create(width, height, 0)) then
            self.State.Watermark.Dragging = true
            self.State.Watermark.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.Watermark.Dragging then
            self.State.Watermark.Pos = vector.create(self.State.MousePos.x - self.State.Watermark.Offset.x, self.State.MousePos.y - self.State.Watermark.Offset.y, 0)
            pos = self.State.Watermark.Pos
        end
    end

    RCM.Rect(vector.create(pos.x, pos.y, RCM.Layer.Base), vector.create(width, height, 0), self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, RCM.Layer.Section), vector.create(width - 2, height - 2, 0), self.Theme.Background, 1)
    RCM.Rect(vector.create(pos.x, pos.y, RCM.Layer.Item), vector.create(width, 2, 0), self.Theme.Accent, 1)
    
    for i, line in ipairs(lines) do
        RCM.Label(vector.create(pos.x + 10, pos.y + 4 + ((i-1)*14), RCM.Layer.Text), line, self.Theme.Text)
    end
end

function RCM:DrawKeybindList()
    if not self.State.KeybindList.Visible then return end
    local itemsToShow = {}
    for _, bind in ipairs(RCM.Binders) do
        if self.State.KeybindList.Mode == "Always" then table.insert(itemsToShow, bind)
        elseif self.State.KeybindList.Mode == "Active" and bind.active then table.insert(itemsToShow, bind) end
    end
    if #itemsToShow == 0 and not self.State.Enabled then return end

    local maxWidth = 130
    local headerHeight = 24
    
    -- Pre-calculate list height/width
    local totalH = headerHeight
    for _, b in ipairs(itemsToShow) do
        local txt = string.format("[%s] %s", b.key, b.name)
        local lines = WrapText(txt, 40) -- Wrap Keybinds if huge
        
        local w = (7 * 40) + 10 -- Cap width visual
        for _, l in ipairs(lines) do
            local lw = (7 * #l) + 20
            if lw > maxWidth then maxWidth = lw end
        end
        totalH = totalH + (18 * #lines)
    end
    totalH = totalH + 4

    local pos = self.State.KeybindList.Pos
    local size = vector.create(maxWidth, totalH, 0)

    if self.State.Enabled then
        local click = self.State.MouseDown and not self.State.MouseHeld
        if click and self:IsMouseOver(pos, vector.create(maxWidth, headerHeight, 0)) then
            self.State.KeybindList.Dragging = true
            self.State.KeybindList.Offset = vector.create(self.State.MousePos.x - pos.x, self.State.MousePos.y - pos.y, 0)
        end
        if self.State.KeybindList.Dragging then
            self.State.KeybindList.Pos = vector.create(self.State.MousePos.x - self.State.KeybindList.Offset.x, self.State.MousePos.y - self.State.KeybindList.Offset.y, 0)
            pos = self.State.KeybindList.Pos
        end
    end

    RCM.Rect(vector.create(pos.x, pos.y, RCM.Layer.Base), size, self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x + 1, pos.y + 1, RCM.Layer.Section), vector.create(maxWidth - 2, totalH - 2, 0), self.Theme.Background, 1)
    RCM.Rect(vector.create(pos.x, pos.y, RCM.Layer.Item), vector.create(maxWidth, 2, 0), self.Theme.Accent, 1)
    RCM.Label(vector.create(pos.x + (maxWidth/2) - 20, pos.y + 5, RCM.Layer.Text), "Keybinds", self.Theme.Text)
    
    local cy = pos.y + 26
    for _, bind in ipairs(itemsToShow) do
        local col = bind.active and self.Theme.Accent or self.Theme.TextDim
        local txt = string.format("[%s] %s", bind.key, bind.name)
        local lines = WrapText(txt, 40)
        
        for _, l in ipairs(lines) do
            RCM.Label(vector.create(pos.x + 5, cy, RCM.Layer.Text), l, col)
            cy = cy + 18
        end
    end
end

-- [ 4 ] Library Core
function Library:Window(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end
    if props.Name then RCM.State.Watermark.Text = props.Name end

    local window = {
        name = props.Name or "Severe UI",
        pos = props.Position or vector.create(200, 200, 0),
        size = vector.create(WIN_W, 0, 0),
        dragging = false,
        dragOffset = vector.create(0,0,0),
        pages = {},
        activePage = 1
    }

    function window:Draw()
        if not RCM.State.Enabled then return end

        local x, y = self.pos.x, self.pos.y
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld

        if click and RCM:IsMouseOver(self.pos, vector.create(WIN_W, 30, 0)) then
            self.dragging = true
            self.dragOffset = vector.create(RCM.State.MousePos.x - x, RCM.State.MousePos.y - y, 0)
        end
        if self.dragging then
            if RCM.State.MouseDown then
                self.pos = vector.create(RCM.State.MousePos.x - self.dragOffset.x, RCM.State.MousePos.y - self.dragOffset.y, 0)
            else self.dragging = false end
        end

        local page = self.pages[self.activePage]
        local leftY, rightY = 55, 55
        
        -- PRE-CALCULATE HEIGHT
        if page then
            for _, section in ipairs(page.sections) do
                local h = 25
                for _, item in ipairs(section.items) do
                    -- [ FIX ] Strict Limits for Height Calc
                    local limit = 26 -- Default
                    if item.type == "slider" then limit = 15 end
                    if item.type == "binder" then limit = 24 end
                    
                    local lines = WrapText(item.name, limit)
                    local itemH = 24 + ((#lines - 1) * 14)
                    
                    h = h + itemH
                    if item.type == "dropdown" and item.open then h = h + (#item.options * 20)
                    elseif item.type == "colorpicker" and item.open then h = h + 70 end
                end
                if section.side == "Left" then section.renderY = leftY; leftY = leftY + h + 10
                else section.renderY = rightY; rightY = rightY + h + 10 end
            end
        end
        
        local totalH = math.max(leftY, rightY)
        self.size = vector.create(WIN_W, totalH + 10, 0)

        RCM.Rect(vector.create(x, y, RCM.Layer.Base), self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x + 1, y + 1, RCM.Layer.Section), vector.create(WIN_W - 2, totalH + 8, 0), RCM.Theme.Background, 1)
        RCM.Rect(vector.create(x, y, RCM.Layer.Item), vector.create(WIN_W, 2, 0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x + 10, y + 5, RCM.Layer.Text), self.name, RCM.Theme.Text)
        
        local tabX = 10
        local tabY = 25
        for i, pg in ipairs(self.pages) do
            local w = (7 * #pg.name) + 20
            local isAct = (self.activePage == i)
            local col = isAct and RCM.Theme.Accent or RCM.Theme.TextDim
            if click and RCM:IsMouseOver(vector.create(x + tabX, y + tabY, 0), vector.create(w, 20, 0)) then self.activePage = i end
            RCM.Label(vector.create(x + tabX + 5, y + tabY, RCM.Layer.Text), pg.name, col)
            if isAct then RCM.Rect(vector.create(x + tabX + 5, y + tabY + 15, RCM.Layer.Text), vector.create(w - 10, 1, 0), RCM.Theme.Accent, 1) end
            tabX = tabX + w
        end
        RCM.Rect(vector.create(x + 10, y + 45, RCM.Layer.Text), vector.create(530, 1, 0), RCM.Theme.Section, 1)

        if page then
            for _, section in ipairs(page.sections) do
                local sx = (section.side == "Left") and (x + 12) or (x + 12 + 260 + 10)
                local sy = y + section.renderY
                
                local sh = 25
                for _, item in ipairs(section.items) do
                    -- [ FIX ] Strict Limits for Section Box
                    local limit = 26
                    if item.type == "slider" then limit = 15 end
                    if item.type == "binder" then limit = 24 end
                    
                    local lines = WrapText(item.name, limit)
                    local itemH = 24 + ((#lines - 1) * 14)
                    sh = sh + itemH
                    if item.type == "dropdown" and item.open then sh = sh + (#item.options * 20)
                    elseif item.type == "colorpicker" and item.open then sh = sh + 70 end
                end
                
                RCM.Rect(vector.create(sx, sy, RCM.Layer.Section), vector.create(COL_W, sh, 0), RCM.Theme.Border, 1)
                RCM.Rect(vector.create(sx + 1, sy + 1, RCM.Layer.Section), vector.create(COL_W - 2, sh - 2, 0), RCM.Theme.SectionBg, 1)
                RCM.Rect(vector.create(sx, sy, RCM.Layer.Item), vector.create(COL_W, 2, 0), RCM.Theme.Accent, 1)
                RCM.Label(vector.create(sx + 8, sy + 5, RCM.Layer.Text), section.name, RCM.Theme.Text)
                
                local cy = sy + 25
                for _, item in ipairs(section.items) do
                    local nameX = sx + 10
                    local valX  = sx + COL_W - 15
                    local zItem = RCM.Layer.Text
                    
                    -- [ FIX ] Determine Limit based on Type
                    local charLimit = 26 -- Default (Button/Toggle/Dropdown)
                    if item.type == "slider" then charLimit = 15 end
                    if item.type == "binder" then charLimit = 24 end
                    
                    local lines = WrapText(item.name, charLimit)
                    local iH = 24 + ((#lines - 1) * 14)
                    
                    local itemPos = vector.create(sx + 5, cy, 0)
                    local hover = RCM:IsMouseOver(itemPos, vector.create(COL_W - 10, iH - 4, 0))
                    local iClick = hover and click
                    if hover then RCM.Rect(vector.create(itemPos.x, itemPos.y, RCM.Layer.Item), vector.create(COL_W - 10, iH - 4, 0), RCM.Theme.Hover, 0.5) end
                    
                    for i, line in ipairs(lines) do
                        RCM.Label(vector.create(nameX, cy + 3 + ((i-1)*14), zItem), line, RCM.Theme.Text)
                    end
                    
                    if item.type == "toggle" then
                        if iClick then item.value = not item.value; item.callback(item.value) end
                        local boxCol = item.value and RCM.Theme.Accent or RCM.Theme.Section
                        RCM.Rect(vector.create(valX - 10, cy + 5, zItem), vector.create(10, 10, 0), RCM.Theme.Border, 1)
                        RCM.Rect(vector.create(valX - 9, cy + 6, zItem), vector.create(8, 8, 0), boxCol, 1)

                    elseif item.type == "button" then
                        if iClick then item.callback() end

                    elseif item.type == "slider" then
                        if hover and isleftpressed() then
                            local pct = math.clamp((RCM.State.MousePos.x - (valX - 100)) / 100, 0, 1)
                            local nv = math.floor(item.min + (item.max - item.min) * pct)
                            if nv ~= item.value then item.value = nv; item.callback(nv) end
                        end
                        RCM.Label(vector.create(valX - 120, cy + 3, zItem), tostring(item.value), RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 100, cy + 8, zItem), vector.create(100, 4, 0), RCM.Theme.Background, 1)
                        RCM.Rect(vector.create(valX - 100, cy + 8, zItem), vector.create(((item.value - item.min)/(item.max - item.min))*100, 4, 0), RCM.Theme.Accent, 1)

                    elseif item.type == "dropdown" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(valX - (7*#item.selected), cy + 3, zItem), item.selected, RCM.Theme.Accent)
                        if item.open then
                            local dy = cy + iH
                            for _, opt in ipairs(item.options) do
                                local oPos = vector.create(sx + 15, dy, 0)
                                if RCM:IsMouseOver(oPos, vector.create(230, 18, 0)) then
                                    RCM.Rect(vector.create(oPos.x, oPos.y, RCM.Layer.Popup), vector.create(230, 18, 0), RCM.Theme.Hover, 0.5)
                                    if click then item.selected = opt; item.open = false; item.callback(opt) end
                                end
                                RCM.Label(vector.create(sx + 20, dy + 2, RCM.Layer.Popup), opt, (item.selected == opt) and RCM.Theme.Accent or RCM.Theme.Text)
                                dy = dy + 20
                            end
                            iH = iH + (#item.options * 20)
                        end

                    elseif item.type == "binder" then
                        if iClick then item.listening = not item.listening end
                        local txt = "[" .. (item.listening and "..." or item.key) .. "]"
                        RCM.Label(vector.create(valX - (7*#txt), cy + 3, zItem), txt, item.listening and RCM.Theme.Accent or RCM.Theme.TextDim)

                    elseif item.type == "colorpicker" then
                        if iClick then item.open = not item.open end
                        RCM.Rect(vector.create(valX - 15, cy + 5, zItem), vector.create(20, 10, 0), item.color, 1)
                        if item.open then
                            local py = cy + iH
                            local function slider(c, v, m)
                                if RCM:IsMouseOver(vector.create(sx+15, py, 0), vector.create(230, 15, 0)) and isleftpressed() then
                                    local p = math.clamp((RCM.State.MousePos.x - (sx+40)) / 150, 0, 1)
                                    v = math.floor(p * m)
                                end
                                RCM.Label(vector.create(sx+20, py, RCM.Layer.Popup), c, RCM.Theme.Text)
                                RCM.Rect(vector.create(sx+40, py+5, RCM.Layer.Popup), vector.create(150, 4, 0), RCM.Theme.Background, 1)
                                RCM.Rect(vector.create(sx+40, py+5, RCM.Layer.Popup), vector.create((v/m)*150, 4, 0), RCM.Theme.Accent, 1)
                                py = py + 20
                                return v
                            end
                            local r = slider("R", math.floor(item.color.R*255), 255)
                            local g = slider("G", math.floor(item.color.G*255), 255)
                            local b = slider("B", math.floor(item.color.B*255), 255)
                            local nc = Color3.fromRGB(r,g,b)
                            if nc ~= item.color then item.color = nc; item.callback(nc) end
                            iH = iH + 70
                        end
                    end

                    if item.tooltip then
                        local lastLine = lines[#lines]
                        local nameW = (7 * #lastLine)
                        local tipX = nameX + nameW + 8
                        local tipY = cy + 3 + ((#lines-1)*14)
                        local tipPos = vector.create(tipX, tipY, zItem)
                        RCM.Label(tipPos, "(?)", RCM.Theme.Section)
                        if RCM:IsMouseOver(tipPos, vector.create(15, 13, 0)) then RCM.State.ActiveTooltip = item.tooltip end
                    end

                    cy = cy + iH
                end
            end
        end
    end

    function window:Page(props)
        local page = { name = props.Name, sections = {} }
        function page:Section(props)
            local section = { name = props.Name, side = props.Side or "Left", items = {} }
            function section:Toggle(p) table.insert(section.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Slider(p) table.insert(section.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Button(p) table.insert(section.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Dropdown(p) table.insert(section.items, {type="dropdown", name=p.Name, options=p.Options, selected=p.Default, open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            function section:Binder(p) 
                local b = {type="binder", name=p.Name, key=p.Default or "None", active=false, listening=false, callback=p.Callback, tooltip=p.Tooltip}
                table.insert(section.items, b); table.insert(RCM.Binders, b)
            end
            function section:ColorPicker(p) table.insert(section.items, {type="colorpicker", name=p.Name, color=p.Default or Color3.new(1,1,1), open=false, callback=p.Callback, tooltip=p.Tooltip}) end
            table.insert(page.sections, section)
            return section
        end
        table.insert(self.pages, page)
        return page
    end
    return window
end

function Library:SaveConfig(name)
    local data = {}
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if item.type == "toggle" then data[item.name] = item.value
                    elseif item.type == "slider" then data[item.name] = item.value
                    elseif item.type == "dropdown" then data[item.name] = item.selected
                    elseif item.type == "binder" then data[item.name] = item.key
                    elseif item.type == "colorpicker" then data[item.name] = {R=item.color.R, G=item.color.G, B=item.color.B} end
                end
            end
        end
    end
    writefile(name .. ".json", crypt.json.encode(data))
end

function Library:LoadConfig(name)
    if not isfile(name .. ".json") then return end
    local data = crypt.json.decode(readfile(name .. ".json"))
    for _, win in ipairs(RCM.Windows) do
        for _, page in ipairs(win.pages) do
            for _, sec in ipairs(page.sections) do
                for _, item in ipairs(sec.items) do
                    if data[item.name] ~= nil then
                        if item.type == "toggle" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "slider" then item.value = data[item.name]; if item.callback then item.callback(item.value) end
                        elseif item.type == "dropdown" then item.selected = data[item.name]; if item.callback then item.callback(item.selected) end
                        elseif item.type == "binder" then item.key = data[item.name]; if item.callback then item.callback(item.key) end
                        elseif item.type == "colorpicker" then 
                            local c = data[item.name]; item.color = Color3.new(c.R, c.G, c.B); if item.callback then item.callback(item.color) end 
                        end
                    end
                end
            end
        end
    end
end

function RCM:Init()
    local renderEvent = nil
    if RunService and RunService.Render then renderEvent = RunService.Render
    elseif game then renderEvent = game:GetService("RunService").RenderStepped end
    if not renderEvent then return warn("No Render event found") end
    local function Connect(event, cb)
        local s, res = pcall(function() return event:Connect(cb) end)
        if s then return res end
        s, res = pcall(function() return event:connect(cb) end)
        if s then return res end
        warn("Failed to connect to Render event")
    end

    Connect(renderEvent, function()
        self:UpdateInput()
        self:UpdateBinders()
        self.State.ActiveTooltip = nil
        self:DrawWatermark()
        self:DrawKeybindList()
        for _, win in ipairs(self.Windows) do win:Draw() end
        if self.State.ActiveTooltip then
            local t = self.State.ActiveTooltip
            local mp = self.State.MousePos
            local w = (8*#t)+12
            local tx, ty = mp.x+12, mp.y+12
            if (tx+w)>self.State.ScreenSize.x then tx=self.State.ScreenSize.x-w-5 end
            if (ty+20)>self.State.ScreenSize.y then ty=self.State.ScreenSize.y-25 end
            RCM.Rect(vector.create(tx,ty,RCM.Layer.Tooltip), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(tx+1,ty+1,RCM.Layer.Tooltip), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(tx+5,ty+3,RCM.Layer.Tooltip), t, RCM.Theme.Text)
        end
    end)
end

RCM.Windows = {}
function RCM:CreateWindow(props)
    local win = Library:Window(props)
    table.insert(self.Windows, win)
    return win
end

RCM:Init()
return RCM
