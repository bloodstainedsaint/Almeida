--!optimization 2
-- [ RCM ] Severe UI Library v8.3 (Stable)
-- Features: Multi-Select, Binders, Tooltips, Runtime Flags
-- Fixed: Tooltip Stuck Bug (Resets state every frame)

local RCM = {}

print("[RCM] Library Initialized v8.3 Stable")

-- [ 1 ] Configuration & Theme
RCM.Theme = {
    Background = Color3.new(0.08, 0.08, 0.08),
    SectionBg  = Color3.new(0.12, 0.12, 0.12),
    Border     = Color3.new(0.0, 0.0, 0.0),
    Accent     = Color3.new(0.8039, 0.0, 0.4980),
    Text       = Color3.new(0.9, 0.9, 0.9),
    TextDim    = Color3.new(0.5, 0.5, 0.5),
    Hover      = Color3.new(0.16, 0.16, 0.16),
    TooltipBg  = Color3.new(0.05, 0.05, 0.05),
    InfoWinBg  = Color3.new(0.1, 0.1, 0.1),
    Link       = Color3.new(0.4, 0.6, 1),
    Section    = Color3.new(0.25, 0.25, 0.25)
}

RCM.Layer = { Base = 0, Section = 1, Item = 2, Text = 3, Popup = 20, InfoWin = 100, Notif = 200, Tooltip = 300 }
local WIN_W, COL_W = 550, 260

RCM.State = {
    Enabled = true,
    MousePos = vector.create(0, 0, 0),
    MouseDown = false, MouseHeld = false,
    RightMouseDown = false, RightMouseHeld = false,
    ToggleKey = "Delete", LastToggle = 0,
    ActiveTooltip = nil, ActivePopup = nil,
    ScreenSize = vector.create(1920, 1080, 0),
    Watermark = { Visible = true, Text = "Severe UI", Extra = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) },
    InfoWindows = {},
    InputBusy = false,
    LastTick = 0, FrameCount = 0, CurrentFPS = 60
}

RCM.Binders = {}
RCM.Notifications = {}
RCM.Windows = {}
RCM.Flags = {} 

-- [ 2 ] Helpers
function RCM.Rect(pos, size, color, alpha) DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1) end
function RCM.Label(pos, text, color, center) DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy") end

local function FitText(text, maxWidth)
    local charWidth = 7 
    if (#text * charWidth) > maxWidth then return string.sub(text, 1, math.floor(maxWidth / charWidth) - 2) .. ".." end
    return text
end

local function WrapText(str, maxChars)
    local lines, currentLine = {}, ""
    for word in str:gmatch("%S+") do
        if #currentLine + #word + 1 > maxChars then table.insert(lines, currentLine); currentLine = word
        else if currentLine == "" then currentLine = word else currentLine = currentLine .. " " .. word end end
    end
    if currentLine ~= "" then table.insert(lines, currentLine) end
    if #lines == 0 then lines = {str} end
    return lines
end

-- [ 3 ] Input Logic
function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then self.State.MousePos = mPos end
    if workspace.CurrentCamera then self.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local lDown = isleftpressed()
    if lDown and not self.State.MouseDown then self.State.MouseDown = true
    elseif lDown and self.State.MouseDown then self.State.MouseHeld = true
    elseif not lDown then
        self.State.MouseDown = false; self.State.MouseHeld = false
        self.State.Watermark.Dragging = false; self.State.KeybindList.Dragging = false
        for _, win in ipairs(self.State.InfoWindows) do win.dragging = false end
        for _, win in ipairs(RCM.Windows) do win.dragging = false end
    end

    local rDown = isrightpressed()
    if rDown and not self.State.RightMouseDown then self.State.RightMouseDown = true
    elseif rDown and self.State.RightMouseDown then self.State.RightMouseHeld = true
    elseif not rDown then self.State.RightMouseDown = false; self.State.RightMouseHeld = false end

    if self.State.MouseDown and not self.State.MouseHeld and self.State.ActivePopup then
        local p = self.State.ActivePopup
        local size = p.Size or vector.create(80, 64, 0)
        if not self:IsMouseOver(p.Pos, size) then self.State.ActivePopup = nil end
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then for _, k in ipairs(keys) do if k == self.State.ToggleKey then isTogglePressed = true break end end end

    if isTogglePressed and (tick() - self.State.LastToggle > 0.3) then
        self.State.Enabled = not self.State.Enabled; self.State.LastToggle = tick()
    end

    self.State.FrameCount = self.State.FrameCount + 1
    if (tick() - self.State.LastTick) >= 1 then
        self.State.CurrentFPS = self.State.FrameCount; self.State.FrameCount = 0; self.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end
    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" and k ~= "RightMouse" then
                    bind.key = k; bind.listening = false;
                    if bind.callback then bind.callback(bind.key) end
                    if bind.flag then RCM.Flags[bind.flag] = { Key = k, Mode = bind.mode } end
                end
            end
        else
            local isKeyDown = keyMap[bind.key] == true
            if bind.mode == "Always" then bind.active = true
            elseif bind.mode == "Hold" then bind.active = isKeyDown
            elseif bind.mode == "Toggle" then if isKeyDown and not bind.lastState then bind.active = not bind.active end end
            bind.lastState = isKeyDown
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = self.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x and m.y >= pos.y and m.y <= pos.y + size.y
end

function RCM:SetWatermark(text) self.State.Watermark.Text = text end
function RCM:Notify(msg, duration) table.insert(self.Notifications, {id = tick()..math.random(), text = msg, duration = duration or 3, start = tick(), alpha = 0}) end

-- [ 4 ] WINDOW & DRAWING LOGIC
function RCM:OpenInfoWindow(title, content)
    local processedLines = {}
    if type(content) == "table" then
        for _, item in ipairs(content) do
            if type(item) == "string" then for _, l in ipairs(WrapText(item, 40)) do table.insert(processedLines, {type="text", text=l}) end
            elseif type(item) == "table" then
                if item.Text then table.insert(processedLines, {type="link", text=item.Text, callback=item.Callback})
                elseif item.Type == "sep" then table.insert(processedLines, {type="sep"}) end
            end
        end
    end
    local center = vector.create((self.State.ScreenSize.x / 2) - 150, (self.State.ScreenSize.y / 2) - 100, 0)
    table.insert(self.State.InfoWindows, {id=tick()..math.random(), title=title, items=processedLines, pos=center, dragging=false, dragOffset=vector.create(0,0,0)})
end

function RCM:DrawStandardInterface()
    if self.State.Watermark.Visible then
        local p, t = self.State.Watermark.Pos, self.State.Watermark.Text
        if self.State.Watermark.Extra then t = t.." | FPS: "..self.State.CurrentFPS end
        local sz = vector.create((7*#t)+20, 22, 0)
        if self.State.Enabled and not self.State.InputBusy then
            if self.State.MouseDown and not self.State.MouseHeld and self:IsMouseOver(p, sz) then
                self.State.Watermark.Dragging = true; self.State.Watermark.Offset = vector.create(self.State.MousePos.x-p.x, self.State.MousePos.y-p.y, 0)
            end
            if self.State.Watermark.Dragging then
                self.State.Watermark.Pos = vector.create(self.State.MousePos.x-self.State.Watermark.Offset.x, self.State.MousePos.y-self.State.Watermark.Offset.y, 0)
                p = self.State.Watermark.Pos; self.State.InputBusy = true
            end
        end
        RCM.Rect(p, sz, self.Theme.Border, 1); RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(sz.x-2,sz.y-2,0), self.Theme.Background, 1)
        RCM.Rect(p, vector.create(sz.x,2,0), self.Theme.Accent, 1); RCM.Label(vector.create(p.x+10,p.y+4,3), t, self.Theme.Text)
    end
    
    local startY = 50
    for i=#self.Notifications, 1, -1 do
        local n = self.Notifications[i]; local el = tick()-n.start; local rem = n.duration-el
        if rem <= 0 then table.remove(self.Notifications, i) else
            local bw = (7*#n.text)+20; local px = self.State.ScreenSize.x - bw - 20
            RCM.Rect(vector.create(px,startY,200), vector.create(bw,26,0), self.Theme.Border, 1)
            RCM.Rect(vector.create(px+1,startY+1,200), vector.create(bw-2,24,0), self.Theme.Background, 1)
            RCM.Label(vector.create(px+10,startY+5,200), n.text, RCM.Theme.Text)
            RCM.Rect(vector.create(px+1,startY+23,200), vector.create((bw-2)*(rem/n.duration),2,0), RCM.Theme.Accent, 1)
            startY = startY + 35
        end
    end

    if self.State.KeybindList.Visible and self.State.Enabled then
        local itemsToShow = {}
        for _, bind in ipairs(RCM.Binders) do
            if self.State.KeybindList.Mode == "Always" then table.insert(itemsToShow, bind)
            elseif self.State.KeybindList.Mode == "Active" and bind.active then table.insert(itemsToShow, bind) end
        end
        if #itemsToShow > 0 then
            local p = self.State.KeybindList.Pos
            local mw = 130
            for _, b in ipairs(itemsToShow) do local tw = (7*#b.name) + (7*#b.key) + 50; if tw > mw then mw = tw end end
            local th = 24 + (#itemsToShow * 18) + 4
            
            if not self.State.InputBusy then
                if self.State.MouseDown and not self.State.MouseHeld and self:IsMouseOver(p, vector.create(mw, 24, 0)) then
                    self.State.KeybindList.Dragging = true; self.State.KeybindList.Offset = vector.create(self.State.MousePos.x-p.x, self.State.MousePos.y-p.y, 0)
                end
            end
            if self.State.KeybindList.Dragging then
                if self.State.MouseDown then self.State.KeybindList.Pos = vector.create(self.State.MousePos.x-self.State.KeybindList.Offset.x, self.State.MousePos.y-self.State.KeybindList.Offset.y, 0); p=self.State.KeybindList.Pos; self.State.InputBusy=true else self.State.KeybindList.Dragging=false end
            end
            
            RCM.Rect(p, vector.create(mw, th, 0), self.Theme.Border, 1)
            RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(mw-2, th-2, 0), self.Theme.Background, 1)
            RCM.Rect(p, vector.create(mw, 2, 0), self.Theme.Accent, 1)
            RCM.Label(vector.create(p.x + (mw/2) - 20, p.y + 5, 3), "Keybinds", self.Theme.Text)
            
            local ky = p.y + 26
            for _, b in ipairs(itemsToShow) do
                local col = b.active and self.Theme.Accent or self.Theme.TextDim
                local kt = "["..b.key.."]"
                local mt = (b.mode=="Hold" and "[H]") or (b.mode=="Toggle" and "[T]") or "[A]"
                RCM.Label(vector.create(p.x+5, ky, 3), b.name, self.Theme.Text)
                RCM.Label(vector.create(p.x+mw-(7*#kt)-(7*#mt)-10, ky, 3), kt..mt, col)
                ky = ky + 18
            end
        end
    end
end

function RCM:DrawPopup()
    if not self.State.ActivePopup then return end
    local p = self.State.ActivePopup; local bind = p.BindItem; local pos = p.Pos
    local opts = {"Hold", "Toggle", "Always"}; local w, h = 80, (#opts*20)+4
    RCM.Rect(pos, vector.create(w, h, 20), self.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x+1, pos.y+1, 20), vector.create(w-2, h-2, 0), self.Theme.Background, 1)
    local cy = pos.y + 2
    for _, m in ipairs(opts) do
        local op = vector.create(pos.x+2, cy, 20); local os = vector.create(w-4, 18, 0)
        local hov = self:IsMouseOver(op, os)
        if hov then
            RCM.Rect(op, os, self.Theme.Accent, 0.8)
            if self.State.MouseDown and not self.State.MouseHeld then bind.mode = m; self.State.ActivePopup = nil; return end
        end
        RCM.Label(vector.create(pos.x+5, cy+2, 21), m, (bind.mode==m or hov) and self.Theme.Text or self.Theme.TextDim)
        cy = cy + 20
    end
end

local function LibraryWindow(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end
    local window = { name = props.Name or "UI", pos = props.Position or vector.create(200,200,0), size = vector.create(WIN_W,0,0), dragging=false, dragOffset=vector.create(0,0,0), pages={}, activePage=1 }

    function window:Draw()
        if not RCM.State.Enabled then return end
        local rClick = RCM.State.RightMouseDown and not RCM.State.RightMouseHeld
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld
        
        if not RCM.State.InputBusy and click and RCM:IsMouseOver(self.pos, vector.create(WIN_W, 30, 0)) then
            self.dragging = true; self.dragOffset = vector.create(RCM.State.MousePos.x - self.pos.x, RCM.State.MousePos.y - self.pos.y, 0)
        end
        if self.dragging then
            if RCM.State.MouseDown then self.pos = vector.create(RCM.State.MousePos.x - self.dragOffset.x, RCM.State.MousePos.y - self.dragOffset.y, 0); RCM.State.InputBusy = true
            else self.dragging = false end
        end
        if RCM.State.InputBusy and not self.dragging then click = false end

        local page = self.pages[self.activePage]; local lY, rY = 55, 55
        if page then
            for _, s in ipairs(page.sections) do
                local h = 25
                for _, it in ipairs(s.items) do
                    local add = 24
                    if it.type == "dropdown" and it.open then add = add + (#it.options * 20) end
                    if it.type == "colorpicker" and it.open then add = add + 70 end
                    h = h + add
                end
                if s.side == "Left" then s.ry = lY; lY=lY+h+10 else s.ry = rY; rY=rY+h+10 end
            end
        end
        local totalH = math.max(lY, rY)

        local x, y = self.pos.x, self.pos.y
        RCM.Rect(vector.create(x,y,0), vector.create(WIN_W, totalH+10,0), RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x+1,y+1,1), vector.create(WIN_W-2, totalH+8,0), RCM.Theme.Background, 1)
        RCM.Rect(vector.create(x,y,2), vector.create(WIN_W,2,0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x+10,y+5,3), self.name, RCM.Theme.Text)
        RCM.Rect(vector.create(x+10,y+45,3), vector.create(WIN_W-20,1,0), RCM.Theme.Section, 1)

        local tx = 10
        for i, pg in ipairs(self.pages) do
            local w = (7*#pg.name)+20
            if click and RCM:IsMouseOver(vector.create(x+tx,y+25,0), vector.create(w,20,0)) then self.activePage = i end
            RCM.Label(vector.create(x+tx+5,y+25,3), pg.name, (self.activePage==i) and RCM.Theme.Accent or RCM.Theme.TextDim)
            if self.activePage==i then RCM.Rect(vector.create(x+tx+5,y+40,3), vector.create(w-10,1,0), RCM.Theme.Accent, 1) end
            tx = tx + w
        end

        if page then
            for _, sect in ipairs(page.sections) do
                local sx = (sect.side == "Left") and (x+12) or (x+12+COL_W+10); local sy = y+sect.ry
                local sh = 25
                for _, it in ipairs(sect.items) do
                    local add = 24
                    if it.type=="dropdown" and it.open then add=add+(#it.options*20) end
                    if it.type=="colorpicker" and it.open then add=add+70 end
                    sh = sh + add
                end
                
                RCM.Rect(vector.create(sx,sy,1), vector.create(COL_W,sh,0), RCM.Theme.Border, 1)
                RCM.Rect(vector.create(sx+1,sy+1,1), vector.create(COL_W-2,sh-2,0), RCM.Theme.SectionBg, 1)
                RCM.Rect(vector.create(sx,sy,2), vector.create(COL_W,2,0), RCM.Theme.Accent, 1)
                RCM.Label(vector.create(sx+8,sy+5,3), sect.name, RCM.Theme.Text)

                local cy = sy + 25
                for _, item in ipairs(sect.items) do
                    local nmX, valX = sx+10, sx+COL_W-15
                    local iH = 24
                    local itemPos = vector.create(sx+5, cy, 0)
                    local hover = RCM:IsMouseOver(itemPos, vector.create(COL_W-10, iH-4, 0))
                    local iClick = hover and click
                    local iRClick = hover and rClick
                    if hover then RCM.Rect(itemPos, vector.create(COL_W-10, iH-4, 0), RCM.Theme.Hover, 0.5) end

                    if item.type == "toggle" then
                        if iClick then item.value = not item.value; if item.callback then item.callback(item.value) end; if item.flag then RCM.Flags[item.flag] = item.value end end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX-10, cy+5, 3), vector.create(10,10,0), RCM.Theme.Border, 1)
                        RCM.Rect(vector.create(valX-9, cy+6, 3), vector.create(8,8,0), item.value and RCM.Theme.Accent or RCM.Theme.Section, 1)

                    elseif item.type == "slider" then
                        if hover and isleftpressed() and not RCM.State.InputBusy then
                            local pct = math.clamp((RCM.State.MousePos.x - (valX - 100)) / 100, 0, 1)
                            local nv = math.floor(item.min + (item.max - item.min) * pct)
                            if nv ~= item.value then 
                                item.value = nv; 
                                if item.callback then item.callback(nv) end 
                                if item.flag then RCM.Flags[item.flag] = nv end
                            end
                        end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - 120, cy + 3, 3), tostring(item.value), RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(100, 4, 0), RCM.Theme.Background, 1)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(((item.value - item.min)/(item.max - item.min))*100, 4, 0), RCM.Theme.Accent, 1)

                    elseif item.type == "dropdown" then
                        if iClick then item.open = not item.open end
                        local dispText = item.selected
                        if item.multi then
                            local active = {}
                            for k,v in pairs(item.selected) do if v then table.insert(active, k) end end
                            if #active == 0 then dispText = "None"
                            elseif #active > 2 then dispText = #active .. " Selected"
                            else dispText = table.concat(active, ", ") end
                        end
                        RCM.Label(vector.create(nmX, cy+3, 3), FitText(item.name, 120), RCM.Theme.Text)
                        RCM.Label(vector.create(valX-(7*#dispText), cy+3, 3), dispText, RCM.Theme.Accent)
                        if item.open then
                            local dy = cy + 24
                            for _, opt in ipairs(item.options) do
                                local oPos = vector.create(sx+15, dy, 0)
                                if RCM:IsMouseOver(oPos, vector.create(230, 18, 0)) then
                                    RCM.Rect(oPos, vector.create(230, 18, 0), RCM.Theme.Hover, 0.5)
                                    if click then
                                        if item.multi then
                                            item.selected[opt] = not item.selected[opt]
                                            if item.callback then item.callback(item.selected) end
                                            if item.flag then RCM.Flags[item.flag] = item.selected end
                                        else
                                            item.selected = opt; item.open = false
                                            if item.callback then item.callback(opt) end
                                            if item.flag then RCM.Flags[item.flag] = opt end
                                        end
                                    end
                                end
                                local isSel = false
                                if item.multi then isSel = item.selected[opt] else isSel = (item.selected == opt) end
                                RCM.Label(vector.create(sx+20, dy+2, 20), opt, isSel and RCM.Theme.Accent or RCM.Theme.Text)
                                dy = dy + 20
                            end
                            iH = iH + (#item.options * 20)
                        end
                        
                    elseif item.type == "button" then
                        if iClick and item.callback then item.callback() end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, hover and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "colorpicker" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 15, cy + 5, 3), vector.create(20, 10, 0), item.color, 1)
                        if item.open then
                            local py = cy + 24
                            local function slider(c, v, m)
                                if RCM:IsMouseOver(vector.create(sx+15, py, 0), vector.create(COL_W-30, 15, 0)) and isleftpressed() then
                                    local p = math.clamp((RCM.State.MousePos.x - (sx+40)) / 150, 0, 1)
                                    v = math.floor(p * m)
                                end
                                RCM.Label(vector.create(sx+20, py, 20), c, RCM.Theme.Text)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create(150, 4, 0), RCM.Theme.Background, 1)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create((v/m)*150, 4, 0), RCM.Theme.Accent, 1)
                                py = py + 20
                                return v
                            end
                            local r = slider("R", math.floor(item.color.R*255), 255)
                            local g = slider("G", math.floor(item.color.G*255), 255)
                            local b = slider("B", math.floor(item.color.B*255), 255)
                            local nc = Color3.fromRGB(r,g,b)
                            if nc ~= item.color then 
                                item.color = nc; if item.callback then item.callback(nc) end; if item.flag then RCM.Flags[item.flag] = {R=nc.R, G=nc.G, B=nc.B} end 
                            end
                            iH = iH + 70
                        end
                    
                    elseif item.type == "binder" then
                        if iClick then item.listening = not item.listening end
                        if iRClick then RCM.State.ActivePopup = { BindItem = item, Pos = RCM.State.MousePos } end
                        local txt = "[" .. (item.listening and "..." or item.key) .. "]"
                        local keyW = (7 * #txt)
                        RCM.Label(vector.create(nmX, cy + 3, 3), FitText(item.name, 230 - keyW), RCM.Theme.Text)
                        RCM.Label(vector.create(valX - keyW, cy + 3, 3), txt, item.listening and RCM.Theme.Accent or RCM.Theme.TextDim)
                    end

                    if item.tooltip then
                         local tipPos = vector.create(nmX + (7*#item.name) + 8, cy+3, 3)
                         RCM.Label(tipPos, "(?)", RCM.Theme.TextDim)
                         if RCM:IsMouseOver(tipPos, vector.create(15,13,0)) then RCM.State.ActiveTooltip = item.tooltip end
                    end
                    cy = cy + iH
                end
            end
        end
    end
    
    function window:Page(p)
        local pg = {name=p.Name, sections={}}
        function pg:Section(p)
            local sec = {name=p.Name, side=p.Side or "Left", items={}}
            function sec:Toggle(p) table.insert(sec.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or false end end
            function sec:Slider(p) table.insert(sec.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or p.Min end end
            function sec:Dropdown(p) 
                local sel = p.Default; if p.Multi and type(sel) ~= "table" then sel = {} end 
                table.insert(sec.items, {type="dropdown", name=p.Name, options=p.Options, selected=sel, open=false, multi=p.Multi, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = sel end 
            end
            function sec:Button(p) table.insert(sec.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function sec:ColorPicker(p) 
                local c = p.Default or Color3.new(1,1,1)
                table.insert(sec.items, {type="colorpicker", name=p.Name, color=c, open=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = {R=c.R, G=c.G, B=c.B} end
            end
            function sec:Binder(p) 
                local b = {type="binder", name=p.Name, key=p.Default or "None", mode="Hold", active=false, listening=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}
                table.insert(sec.items, b); table.insert(RCM.Binders, b)
                if p.Flag then RCM.Flags[p.Flag] = { Key = b.key, Mode = b.mode } end
            end
            table.insert(pg.sections, sec)
            return sec
        end
        table.insert(self.pages, pg)
        return pg
    end
    return window
end

function RCM:CreateWindow(p) local w=LibraryWindow(p); table.insert(self.Windows, w); return w end

function RCM:Init()
    local ren = RunService.Render or game:GetService("RunService").RenderStepped
    ren:Connect(function()
        self.State.InputBusy = false
        self.State.ActiveTooltip = nil -- [FIX] Reset tooltip every frame
        self:UpdateInput()
        self:UpdateBinders()
        self:DrawStandardInterface()
        for _, w in ipairs(self.Windows) do w:Draw() end
        self:DrawPopup()
        if self.State.ActiveTooltip and not self.State.ActivePopup and self.State.Enabled then
            local t, m = self.State.ActiveTooltip, self.State.MousePos
            local w = (8*#t)+12
            RCM.Rect(vector.create(m.x+12,m.y+12,RCM.Layer.Tooltip), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(m.x+13,m.y+13,RCM.Layer.Tooltip), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(m.x+17,m.y+15,RCM.Layer.Tooltip), t, RCM.Theme.Text)
        end
    end)
end

RCM:Init()

return RCM
