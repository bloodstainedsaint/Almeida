--!optimization 2
-- [ RCM ] Severe UI Library v10.2 (Modern Theme)
-- Updated: Dark Slate/Violet Theme, cleaner visuals.
-- Features: Edit Mode, Z-Index Layering, Widget Snapping

local RCM = {}

print("[RCM] Library Initialized v10.2 Modern")

-- [ 1 ] Configuration & Theme (MODERNIZED)
RCM.Theme = {
    Background   = Color3.fromRGB(18, 18, 22),      -- Deep dark slate
    SectionBg    = Color3.fromRGB(24, 24, 28),      -- Slightly lighter for sections
    Border       = Color3.fromRGB(42, 42, 48),      -- Subtle dark border (not harsh black)
    Accent       = Color3.fromRGB(113, 100, 222),   -- Modern "Blurple"/Violet Accent
    Text         = Color3.fromRGB(225, 225, 230),   -- Soft White (Easier on eyes)
    TextDim      = Color3.fromRGB(100, 100, 110),   -- Cool Grey for inactive text
    Hover        = Color3.fromRGB(32, 32, 38),      -- Interaction state
    TooltipBg    = Color3.fromRGB(15, 15, 15),      -- Darker tooltip
    SnapLine     = Color3.fromRGB(113, 100, 222),   -- Snapping lines match accent
    InfoWinBg    = Color3.fromRGB(20, 20, 25),      
    Link         = Color3.fromRGB(88, 166, 255),    -- Bright modern blue
    Section      = Color3.fromRGB(42, 42, 48),      -- Separator lines
    Negative     = Color3.fromRGB(235, 87, 87),     -- Flat Red
    ResizeHandle = Color3.fromRGB(80, 80, 90),      -- Visible but subtle handle
    EditModeText = Color3.fromRGB(255, 180, 60)     -- Golden warning text
}

RCM.Layer = { Base=0, Section=1, Item=2, Text=3, Widget=10, Popup=500, InfoWin=100, Snap=400, Notif=600, Tooltip=700 }
local WIN_W, COL_W = 550, 260

-- [ 2 ] State & Registry
RCM.State = {
    Enabled = true,
    EditMode = false, 
    MousePos = vector.create(0, 0, 0),
    MouseDown = false, MouseHeld = false,
    RightMouseDown = false, RightMouseHeld = false,
    ToggleKey = "Delete", LastToggle = 0,
    ActiveTooltip = nil, 
    ActivePopup = nil, 
    ScreenSize = vector.create(1920, 1080, 0),
    Watermark = { Visible = true, Text = "Severe UI", Extra = true, Pos = vector.create(50, 50, 0), Dragging = false, Offset = vector.create(0,0,0) },
    KeybindList = { Visible = true, Mode = "Always", Pos = vector.create(50, 100, 0), Dragging = false, Offset = vector.create(0,0,0) },
    InfoWindows = {},
    InputBusy = false,
    Snapping = { ActiveLines = {} },
    LastTick = 0, FrameCount = 0, CurrentFPS = 60
}

RCM.Binders = {}
RCM.Notifications = {}
RCM.Windows = {} 
RCM.Widgets = {} 
RCM.Flags = {} 

-- [ 3 ] Helpers
function RCM.Rect(pos, size, color, alpha) DrawingImmediate.FilledRectangle(pos, size, color, alpha or 1) end
function RCM.Label(pos, text, color, center) DrawingImmediate.Text(pos, 13, color, 1, text, center or false, "Proggy") end
function RCM.Line(a, b, color, alpha, thickness) DrawingImmediate.Line(a, b, color, alpha, 1, thickness or 1) end
function RCM.Triangle(a, b, c, color, alpha) DrawingImmediate.FilledTriangle(a, b, c, color, alpha or 1) end

local function FitText(text, maxWidth)
    local charWidth = 7 
    if (#text * charWidth) > maxWidth then return string.sub(text, 1, math.floor(maxWidth / charWidth) - 2) .. ".." end
    return text
end

local function WrapText(str, maxChars)
    local lines, currentLine = {}, ""
    for word in str:gmatch("%S+") do
        if #currentLine + #word + 1 > maxChars then table.insert(lines, currentLine); currentLine = word
        else if currentLine == "" then currentLine = word else currentLine = currentLine .. " " .. word end end
    end
    if currentLine ~= "" then table.insert(lines, currentLine) end
    if #lines == 0 then lines = {str} end
    return lines
end

-- [ 4 ] Core Logic
function RCM:UpdateInput()
    local s, mPos = pcall(getmouseposition)
    if s and mPos then RCM.State.MousePos = mPos end
    if workspace.CurrentCamera then RCM.State.ScreenSize = workspace.CurrentCamera.ViewportSize end

    local lDown = isleftpressed()
    if lDown and not RCM.State.MouseDown then RCM.State.MouseDown = true
    elseif lDown and RCM.State.MouseDown then RCM.State.MouseHeld = true
    elseif not lDown then
        RCM.State.MouseDown = false; RCM.State.MouseHeld = false
        RCM.State.Watermark.Dragging = false; RCM.State.KeybindList.Dragging = false
        for _, win in ipairs(RCM.State.InfoWindows) do win.dragging = false end
        for _, win in ipairs(RCM.Windows) do win.dragging = false end
        for _, wid in ipairs(RCM.Widgets) do wid.dragging = false; wid.resizing = false end
        RCM.State.Snapping.ActiveLines = {} 
    end

    local rDown = isrightpressed()
    if rDown and not RCM.State.RightMouseDown then RCM.State.RightMouseDown = true
    elseif rDown and RCM.State.RightMouseDown then RCM.State.RightMouseHeld = true
    elseif not rDown then RCM.State.RightMouseDown = false; RCM.State.RightMouseHeld = false end

    -- Close Popup logic
    if RCM.State.MouseDown and not RCM.State.MouseHeld and RCM.State.ActivePopup then
        local p = RCM.State.ActivePopup
        local size = p.Size or vector.create(80, 64, 0)
        if p.Type == "Widget" then size = vector.create(120, 44, 0) end
        
        if not RCM:IsMouseOver(p.Pos, size) then RCM.State.ActivePopup = nil end
    end

    local keys = getpressedkeys()
    local isTogglePressed = false
    if keys then for _, k in ipairs(keys) do if k == RCM.State.ToggleKey then isTogglePressed = true break end end end

    if isTogglePressed and (tick() - RCM.State.LastToggle > 0.3) then
        RCM.State.Enabled = not RCM.State.Enabled; RCM.State.LastToggle = tick()
    end

    RCM.State.FrameCount = RCM.State.FrameCount + 1
    if (tick() - RCM.State.LastTick) >= 1 then
        RCM.State.CurrentFPS = RCM.State.FrameCount; RCM.State.FrameCount = 0; RCM.State.LastTick = tick()
    end
end

function RCM:UpdateBinders()
    local keys = getpressedkeys() or {}
    local keyMap = {}
    for _, k in ipairs(keys) do keyMap[k] = true end
    for _, bind in ipairs(RCM.Binders) do
        if bind.listening then
            for _, k in ipairs(keys) do
                if k ~= "Unknown" and k ~= "LeftMouse" and k ~= "RightMouse" then
                    bind.key = k; bind.listening = false;
                    if bind.callback then bind.callback(bind.key) end
                    if bind.flag then RCM.Flags[bind.flag] = { Key = k, Mode = bind.mode } end
                end
            end
        else
            local isKeyDown = keyMap[bind.key] == true
            if bind.mode == "Always" then bind.active = true
            elseif bind.mode == "Hold" then bind.active = isKeyDown
            elseif bind.mode == "Toggle" then if isKeyDown and not bind.lastState then bind.active = not bind.active end end
            bind.lastState = isKeyDown
        end
    end
end

function RCM:IsMouseOver(pos, size)
    local m = RCM.State.MousePos
    return m.x >= pos.x and m.x <= pos.x + size.x and m.y >= pos.y and m.y <= pos.y + size.y
end

function RCM:SetWatermark(text) RCM.State.Watermark.Text = text end
function RCM:Notify(msg, duration) table.insert(RCM.Notifications, {id = tick()..math.random(), text = msg, duration = duration or 3, start = tick(), alpha = 0}) end
function RCM:SetEditMode(val) RCM.State.EditMode = val end

-- ============================================================================
-- [ 5 ] SNAPPING & LAYERING
-- ============================================================================

function RCM:ReorderWidget(widget, action)
    local index = nil
    for i, w in ipairs(RCM.Widgets) do if w == widget then index = i break end end
    if not index then return end
    
    table.remove(RCM.Widgets, index)
    if action == "Front" then
        table.insert(RCM.Widgets, widget) 
    elseif action == "Back" then
        table.insert(RCM.Widgets, 1, widget) 
    end
end

function RCM:GetSnapTargets(currentObj)
    local screen = RCM.State.ScreenSize
    local targetsX = { 0, screen.x / 2, screen.x } 
    local targetsY = { 0, screen.y / 2, screen.y } 
    
    local function Add(other)
        if other == currentObj then return end
        if not other.pos or not other.size then return end
        table.insert(targetsX, other.pos.x)
        table.insert(targetsX, other.pos.x + other.size.x)
        table.insert(targetsY, other.pos.y)
        table.insert(targetsY, other.pos.y + other.size.y)
    end

    for _, w in ipairs(RCM.Windows) do Add(w) end
    for _, w in ipairs(RCM.Widgets) do Add(w) end
    if RCM.State.Watermark.Visible then
        local w = RCM.State.Watermark; local t = w.Text; if w.Extra then t=t.."..." end
        Add({pos=w.Pos, size=vector.create((7*#t)+20, 22, 0)}) 
    end
    return targetsX, targetsY
end

function RCM:CalculateDragSnap(currentObj, rawPos)
    local snapPos = rawPos
    local objSize = currentObj.size or vector.create(0,0,0)
    local targetsX, targetsY = self:GetSnapTargets(currentObj)
    local screen = RCM.State.ScreenSize
    local threshold, lockDist = 15, 8
    
    RCM.State.Snapping.ActiveLines = {} 

    local anchorsX = { 0, objSize.x / 2, objSize.x }
    local anchorsY = { 0, objSize.y / 2, objSize.y }

    local function CheckAxis(val, anchors, targets, isX)
        local best = nil; local minD = threshold
        for _, off in ipairs(anchors) do
            local pt = val + off
            for _, t in ipairs(targets) do
                local diff = math.abs(pt - t)
                if diff < threshold then
                    local alpha = 1 - (diff / threshold)
                    local ls, le
                    if isX then ls=vector.create(t,0,RCM.Layer.Snap); le=vector.create(t,screen.y,0)
                    else ls=vector.create(0,t,RCM.Layer.Snap); le=vector.create(screen.x,t,0) end
                    table.insert(RCM.State.Snapping.ActiveLines, {A=ls, B=le, Alpha=alpha})
                    if diff < lockDist and diff < minD then minD = diff; best = t - off end
                end
            end
        end
        return best or val
    end

    return vector.create(CheckAxis(rawPos.x, anchorsX, targetsX, true), CheckAxis(rawPos.y, anchorsY, targetsY, false), 0)
end

function RCM:CalculateResizeSnap(currentObj, rawSize)
    local snapSize = rawSize
    local pos = currentObj.pos
    local targetsX, targetsY = self:GetSnapTargets(currentObj)
    local screen = RCM.State.ScreenSize
    local threshold, lockDist = 15, 8
    
    RCM.State.Snapping.ActiveLines = {}

    local function CheckAxis(currentSizeVal, posVal, targets, isX)
        local edge = posVal + currentSizeVal 
        local best = nil; local minD = threshold
        
        for _, t in ipairs(targets) do
            local diff = math.abs(edge - t)
            if diff < threshold then
                local alpha = 1 - (diff / threshold)
                local ls, le
                if isX then ls=vector.create(t,0,RCM.Layer.Snap); le=vector.create(t,screen.y,0)
                else ls=vector.create(0,t,RCM.Layer.Snap); le=vector.create(screen.x,t,0) end
                table.insert(RCM.State.Snapping.ActiveLines, {A=ls, B=le, Alpha=alpha})
                
                if diff < lockDist and diff < minD then
                    minD = diff
                    best = t - posVal
                end
            end
        end
        return best or currentSizeVal
    end

    snapSize = vector.create(
        math.max(CheckAxis(rawSize.x, pos.x, targetsX, true), currentObj.minSize.x),
        math.max(CheckAxis(rawSize.y, pos.y, targetsY, false), currentObj.minSize.y),
        0
    )
    return snapSize
end

function RCM:DrawSnapLines()
    if not RCM.State.InputBusy then return end 
    for _, line in ipairs(RCM.State.Snapping.ActiveLines) do
        RCM.Line(line.A, line.B, RCM.Theme.SnapLine, line.Alpha, 2)
        if line.Alpha > 0.5 then RCM.Line(line.A, line.B, RCM.Theme.SnapLine, line.Alpha * 0.3, 4) end
    end
end

-- ============================================================================
-- [ 6 ] WIDGET & WINDOW SYSTEM
-- ============================================================================

function RCM:CreateWidget(props)
    local widget = {
        name = props.Name or "Widget",
        pos = props.Position or vector.create(100, 100, 0),
        size = props.Size or vector.create(100, 100, 0),
        minSize = props.MinSize or vector.create(50, 30, 0),
        resizable = (props.Resizable == nil and true) or props.Resizable, 
        draw = props.Draw, 
        dragging = false, resizing = false,
        dragOffset = vector.create(0,0,0)
    }
    table.insert(RCM.Widgets, widget)
    return widget
end

function RCM:HandleDraggable(obj, ignoreEditMode)
    if not RCM.State.Enabled or (not RCM.State.EditMode and not ignoreEditMode) then
        obj.dragging = false
        obj.resizing = false
        return
    end

    local click = RCM.State.MouseDown and not RCM.State.MouseHeld
    local rClick = RCM.State.RightMouseDown and not RCM.State.RightMouseHeld
    local hovered = RCM:IsMouseOver(obj.pos, obj.size)

    if not RCM.State.InputBusy then
        -- Layering Context Menu (Only in Edit Mode)
        if hovered and rClick and RCM.State.EditMode then
            RCM.State.ActivePopup = { Type = "Widget", Obj = obj, Pos = RCM.State.MousePos }
        end

        -- 1. Check Resize (Bottom Right)
        if obj.resizable and RCM.State.EditMode then
            local handleSize = 15
            local handlePos = vector.create(obj.pos.x + obj.size.x - handleSize, obj.pos.y + obj.size.y - handleSize, 0)
            
            if click and RCM:IsMouseOver(handlePos, vector.create(handleSize, handleSize, 0)) then
                obj.resizing = true
            end
        end

        -- 2. Check Drag (Body)
        if not obj.resizing and click and hovered then
            obj.dragging = true
            obj.dragOffset = vector.create(RCM.State.MousePos.x - obj.pos.x, RCM.State.MousePos.y - obj.pos.y, 0)
        end
    end
    
    if obj.resizing then
        if RCM.State.MouseDown then
            local rawSize = vector.create(RCM.State.MousePos.x - obj.pos.x, RCM.State.MousePos.y - obj.pos.y, 0)
            obj.size = RCM:CalculateResizeSnap(obj, rawSize)
            RCM.State.InputBusy = true
        else
            obj.resizing = false
        end
    elseif obj.dragging then
        if RCM.State.MouseDown then
            local rawPos = vector.create(RCM.State.MousePos.x - obj.dragOffset.x, RCM.State.MousePos.y - obj.dragOffset.y, 0)
            obj.pos = RCM:CalculateDragSnap(obj, rawPos) 
            RCM.State.InputBusy = true
        else
            obj.dragging = false
        end
    end

    -- Draw Visuals (L Bracket) only in Edit Mode
    if obj.resizable and RCM.State.Enabled and RCM.State.EditMode then
        local p = obj.pos; local s = obj.size; local hs = 15 
        local c = (obj.resizing or RCM:IsMouseOver(vector.create(p.x+s.x-hs, p.y+s.y-hs, 0), vector.create(hs,hs,0))) and RCM.Theme.Accent or RCM.Theme.ResizeHandle
        local z = RCM.Layer.Widget+5
        local thick = 3
        
        RCM.Line(vector.create(p.x+s.x, p.y+s.y, z), vector.create(p.x+s.x-hs, p.y+s.y, z), c, 1, thick)
        RCM.Line(vector.create(p.x+s.x, p.y+s.y, z), vector.create(p.x+s.x, p.y+s.y-hs, z), c, 1, thick)
    end
end

-- Main Window Logic
local function LibraryWindow(props)
    if props.ToggleKey then RCM.State.ToggleKey = props.ToggleKey end
    if RCM.Windows[1] then RCM.Windows[1].name = props.Name or RCM.Windows[1].name; return RCM.Windows[1] end

    local window = { name = props.Name or "UI", pos = props.Position or vector.create(200,200,0), size = vector.create(WIN_W, 30, 0), dragging=false, dragOffset=vector.create(0,0,0), pages={}, activePage=1 }

    function window:Draw()
        if not RCM.State.Enabled then return end
        
        local page = self.pages[self.activePage]; local lY, rY = 55, 55
        if page then
            for _, s in ipairs(page.sections) do
                local h = 25
                for _, it in ipairs(s.items) do
                    local add = 24
                    if it.type == "dropdown" and it.open then add = add + (#it.options * 20) end
                    if it.type == "colorpicker" and it.open then add = add + 70 end
                    h = h + add
                end
                if s.side == "Left" then s.ry = lY; lY=lY+h+10 else s.ry = rY; rY=rY+h+10 end
            end
        end
        local totalH = math.max(lY, rY)
        self.size = vector.create(WIN_W, totalH + 10, 0)

        -- [ FIX ] Always allow dragging Main Window (pass true)
        RCM:HandleDraggable(self, true)

        local x, y = self.pos.x, self.pos.y
        local click = RCM.State.MouseDown and not RCM.State.MouseHeld
        if RCM.State.InputBusy and not self.dragging then click = false end

        RCM.Rect(vector.create(x,y,0), self.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(x+2,y+2,1), vector.create(WIN_W-4, totalH+8,0), RCM.Theme.Background, 1)
        RCM.Rect(vector.create(x,y,2), vector.create(WIN_W,2,0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(x+10,y+5,3), self.name, RCM.Theme.Text)
        RCM.Rect(vector.create(x+10,y+45,3), vector.create(WIN_W-20,1,0), RCM.Theme.Section, 1)

        local tx = 10
        for i, pg in ipairs(self.pages) do
            local w = (7*#pg.name)+20
            if click and RCM:IsMouseOver(vector.create(x+tx,y+25,0), vector.create(w,20,0)) then self.activePage = i end
            RCM.Label(vector.create(x+tx+5,y+25,3), pg.name, (self.activePage==i) and RCM.Theme.Accent or RCM.Theme.TextDim)
            if self.activePage==i then RCM.Rect(vector.create(x+tx+5,y+40,3), vector.create(w-10,1,0), RCM.Theme.Accent, 1) end
            tx = tx + w
        end

        if page then
            for _, sect in ipairs(page.sections) do
                local sx = (sect.side == "Left") and (x+12) or (x+12+COL_W+10); local sy = y+sect.ry
                local sh = 25
                for _, it in ipairs(sect.items) do
                    local add = 24
                    if it.type=="dropdown" and it.open then add=add+(#it.options*20) end
                    if it.type=="colorpicker" and it.open then add=add+70 end
                    sh = sh + add
                end
                
                RCM.Rect(vector.create(sx,sy,1), vector.create(COL_W,sh,0), RCM.Theme.Border, 1)
                RCM.Rect(vector.create(sx+2,sy+2,1), vector.create(COL_W-4,sh-4,0), RCM.Theme.SectionBg, 1)
                RCM.Rect(vector.create(sx,sy,2), vector.create(COL_W,2,0), RCM.Theme.Accent, 1)
                RCM.Label(vector.create(sx+8,sy+5,3), sect.name, RCM.Theme.Text)

                local cy = sy + 25
                for _, item in ipairs(sect.items) do
                    local nmX, valX = sx+10, sx+COL_W-15
                    local iH = 24
                    local itemPos = vector.create(sx+5, cy, 0)
                    local hover = RCM:IsMouseOver(itemPos, vector.create(COL_W-10, iH-4, 0))
                    local iClick = hover and click
                    if hover then RCM.Rect(itemPos, vector.create(COL_W-10, iH-4, 0), RCM.Theme.Hover, 0.5) end

                    if item.type == "toggle" then
                        if iClick then item.value = not item.value; if item.callback then item.callback(item.value) end; if item.flag then RCM.Flags[item.flag] = item.value end end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX-10, cy+5, 3), vector.create(10,10,0), RCM.Theme.Border, 1)
                        RCM.Rect(vector.create(valX-9, cy+6, 3), vector.create(8,8,0), item.value and RCM.Theme.Accent or RCM.Theme.Section, 1)

                    elseif item.type == "slider" then
                        if hover and isleftpressed() and not RCM.State.InputBusy then
                            local pct = math.clamp((RCM.State.MousePos.x - (valX - 100)) / 100, 0, 1)
                            local nv = math.floor(item.min + (item.max - item.min) * pct)
                            if nv ~= item.value then 
                                item.value = nv; if item.callback then item.callback(nv) end; if item.flag then RCM.Flags[item.flag] = nv end
                            end
                        end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Label(vector.create(valX - 120, cy + 3, 3), tostring(item.value), RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(100, 4, 0), RCM.Theme.Background, 1)
                        RCM.Rect(vector.create(valX - 100, cy + 8, 3), vector.create(((item.value - item.min)/(item.max - item.min))*100, 4, 0), RCM.Theme.Accent, 1)

                    elseif item.type == "dropdown" then
                        if iClick then item.open = not item.open end
                        local dispText = item.selected
                        if item.multi then
                            local active = {}
                            for k,v in pairs(item.selected) do if v then table.insert(active, k) end end
                            if #active == 0 then dispText = "None" elseif #active > 2 then dispText = #active .. " Selected" else dispText = table.concat(active, ", ") end
                        end
                        RCM.Label(vector.create(nmX, cy+3, 3), FitText(item.name, 120), RCM.Theme.Text)
                        RCM.Label(vector.create(valX-(7*#dispText), cy+3, 3), dispText, RCM.Theme.Accent)
                        if item.open then
                            local dy = cy + 24
                            for _, opt in ipairs(item.options) do
                                local oPos = vector.create(sx+15, dy, 0)
                                if RCM:IsMouseOver(oPos, vector.create(230, 18, 0)) then
                                    RCM.Rect(oPos, vector.create(230, 18, 0), RCM.Theme.Hover, 0.5)
                                    if click then
                                        if item.multi then item.selected[opt] = not item.selected[opt]; if item.callback then item.callback(item.selected) end; if item.flag then RCM.Flags[item.flag] = item.selected end
                                        else item.selected = opt; item.open = false; if item.callback then item.callback(opt) end; if item.flag then RCM.Flags[item.flag] = opt end end
                                    end
                                end
                                local isSel = false; if item.multi then isSel = item.selected[opt] else isSel = (item.selected == opt) end
                                RCM.Label(vector.create(sx+20, dy+2, 20), opt, isSel and RCM.Theme.Accent or RCM.Theme.Text)
                                dy = dy + 20
                            end
                            iH = iH + (#item.options * 20)
                        end
                        
                    elseif item.type == "button" then
                        if iClick and item.callback then item.callback() end
                        RCM.Label(vector.create(nmX, cy+3, 3), item.name, hover and RCM.Theme.Accent or RCM.Theme.Text)

                    elseif item.type == "colorpicker" then
                        if iClick then item.open = not item.open end
                        RCM.Label(vector.create(nmX, cy + 3, 3), item.name, RCM.Theme.Text)
                        RCM.Rect(vector.create(valX - 15, cy + 5, 3), vector.create(20, 10, 0), item.color, 1)
                        if item.open then
                            local py = cy + 24
                            local function slider(c, v, m)
                                if RCM:IsMouseOver(vector.create(sx+15, py, 0), vector.create(COL_W-30, 15, 0)) and isleftpressed() then
                                    local p = math.clamp((RCM.State.MousePos.x - (sx+40)) / 150, 0, 1)
                                    v = math.floor(p * m)
                                end
                                RCM.Label(vector.create(sx+20, py, 20), c, RCM.Theme.Text)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create(150, 4, 0), RCM.Theme.Background, 1)
                                RCM.Rect(vector.create(sx+40, py+5, 20), vector.create((v/m)*150, 4, 0), RCM.Theme.Accent, 1)
                                py = py + 20
                                return v
                            end
                            local r = slider("R", math.floor(item.color.R*255), 255)
                            local g = slider("G", math.floor(item.color.G*255), 255)
                            local b = slider("B", math.floor(item.color.B*255), 255)
                            local nc = Color3.fromRGB(r,g,b)
                            if nc ~= item.color then item.color = nc; if item.callback then item.callback(nc) end; if item.flag then RCM.Flags[item.flag] = {R=nc.R, G=nc.G, B=nc.B} end end
                            iH = iH + 70
                        end
                    
                    elseif item.type == "binder" then
                        if iClick then item.listening = not item.listening end
                        if (RCM.State.RightMouseDown and not RCM.State.RightMouseHeld) and hover then RCM.State.ActivePopup = { BindItem = item, Pos = RCM.State.MousePos, Type = "Binder" } end
                        local txt = "[" .. (item.listening and "..." or item.key) .. "]"
                        local keyW = (7 * #txt)
                        RCM.Label(vector.create(nmX, cy + 3, 3), FitText(item.name, 230 - keyW), RCM.Theme.Text)
                        RCM.Label(vector.create(valX - keyW, cy + 3, 3), txt, item.listening and RCM.Theme.Accent or RCM.Theme.TextDim)
                    end

                    if item.tooltip then
                         local tipPos = vector.create(nmX + (7*#item.name) + 8, cy+3, 3)
                         RCM.Label(tipPos, "(?)", RCM.Theme.TextDim)
                         if RCM:IsMouseOver(tipPos, vector.create(15,13,0)) then RCM.State.ActiveTooltip = item.tooltip end
                    end
                    cy = cy + iH
                end
            end
        end
    end
    
    function window:Page(p)
        for _, pg in ipairs(self.pages) do if pg.name == p.Name then return pg end end
        local pg = {name=p.Name, sections={}}
        function pg:Section(p)
            local sec = {name=p.Name, side=p.Side or "Left", items={}}
            function sec:Toggle(p) table.insert(sec.items, {type="toggle", name=p.Name, value=p.Default or false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or false end end
            function sec:Slider(p) table.insert(sec.items, {type="slider", name=p.Name, value=p.Default or p.Min, min=p.Min, max=p.Max, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = p.Default or p.Min end end
            function sec:Dropdown(p) local sel = p.Default; if p.Multi and type(sel) ~= "table" then sel = {} end; table.insert(sec.items, {type="dropdown", name=p.Name, options=p.Options, selected=sel, open=false, multi=p.Multi, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = sel end end
            function sec:Button(p) table.insert(sec.items, {type="button", name=p.Name, callback=p.Callback, tooltip=p.Tooltip}) end
            function sec:ColorPicker(p) local c = p.Default or Color3.new(1,1,1); table.insert(sec.items, {type="colorpicker", name=p.Name, color=c, open=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}); if p.Flag then RCM.Flags[p.Flag] = {R=c.R, G=c.G, B=c.B} end end
            function sec:Binder(p) local b = {type="binder", name=p.Name, key=p.Default or "None", mode="Hold", active=false, listening=false, callback=p.Callback, flag=p.Flag, tooltip=p.Tooltip}; table.insert(sec.items, b); table.insert(RCM.Binders, b); if p.Flag then RCM.Flags[p.Flag] = { Key = b.key, Mode = b.mode } end end
            table.insert(pg.sections, sec)
            return sec
        end
        table.insert(self.pages, pg)
        return pg
    end
    return window
end

function RCM:CreateWindow(p) local w=LibraryWindow(p); table.insert(self.Windows, w); return w end

-- [ 7 ] INFO & MISC
function RCM:OpenInfoWindow(title, content)
    for i, win in ipairs(RCM.State.InfoWindows) do if win.title == title then table.remove(RCM.State.InfoWindows, i) break end end
    local processedLines = {}
    if type(content) == "table" then
        for _, item in ipairs(content) do
            if type(item) == "string" then for _, l in ipairs(WrapText(item, 40)) do table.insert(processedLines, {type="text", text=l}) end
            elseif type(item) == "table" then
                if item.Text then table.insert(processedLines, {type="link", text=item.Text, callback=item.Callback})
                elseif item.Type == "sep" then table.insert(processedLines, {type="sep"}) end
            end
        end
    end
    local last = RCM.State.InfoWindows[#RCM.State.InfoWindows]
    local spawn = last and vector.create(last.pos.x+20, last.pos.y+20, 0) or vector.create((RCM.State.ScreenSize.x/2)-150, (RCM.State.ScreenSize.y/2)-100, 0)
    local win = {id=tick()..math.random(), title=title, items=processedLines, pos=spawn, dragging=false, dragOffset=vector.create(0,0,0), size=vector.create(300, 200, 0)} 
    table.insert(RCM.State.InfoWindows, win)
end

function RCM:DrawInfoWindows()
    if not RCM.State.Enabled then return end
    for i = #RCM.State.InfoWindows, 1, -1 do
        local win = RCM.State.InfoWindows[i]
        local w, hh, ch = 300, 22, 10
        for _, it in ipairs(win.items) do ch=ch+(it.type=="sep" and 8 or 16) end
        local th = hh + ch
        win.size = vector.create(w, th, 0) 
        
        -- Logic
        if not RCM.State.InputBusy or win.dragging then
            local click = RCM.State.MouseDown and not RCM.State.MouseHeld
            if click and RCM:IsMouseOver(vector.create(win.pos.x+w-20, win.pos.y+2, 0), vector.create(18,18,0)) then table.remove(RCM.State.InfoWindows, i); return end
            if RCM:IsMouseOver(win.pos, vector.create(w, hh, 0)) and click then win.dragging=true; win.dragOffset=vector.create(RCM.State.MousePos.x-win.pos.x, RCM.State.MousePos.y-win.pos.y, 0); table.insert(RCM.State.InfoWindows, table.remove(RCM.State.InfoWindows, i)); return end
            if click then
                local cy = win.pos.y + hh + 5
                for _, item in ipairs(win.items) do
                    if item.type=="link" and RCM:IsMouseOver(vector.create(win.pos.x+10,cy,0), vector.create(7*#item.text, 14, 0)) then if item.callback then item.callback() end end
                    cy = cy + (item.type=="sep" and 8 or 16)
                end
            end
        end
        
        if win.dragging then 
            if RCM.State.MouseDown then
                local raw = vector.create(RCM.State.MousePos.x-win.dragOffset.x, RCM.State.MousePos.y-win.dragOffset.y, 0)
                win.pos = RCM:CalculateDragSnap(win, raw) 
                RCM.State.InputBusy=true 
            else win.dragging = false end
        end

        -- Render
        RCM.Rect(win.pos, win.size, RCM.Theme.Border, 1)
        RCM.Rect(vector.create(win.pos.x+1,win.pos.y+1,RCM.Layer.InfoWin+i), vector.create(w-2, th-2, 0), RCM.Theme.InfoWinBg, 1)
        RCM.Rect(win.pos, vector.create(w, 2, 0), RCM.Theme.Accent, 1)
        RCM.Label(vector.create(win.pos.x+10, win.pos.y+4, RCM.Layer.InfoWin+i+1), win.title, RCM.Theme.Text)
        RCM.Label(vector.create(win.pos.x+w-15, win.pos.y+4, RCM.Layer.InfoWin+i+1), "X", RCM.Theme.Negative)
        
        local cy = win.pos.y + hh + 5
        for _, item in ipairs(win.items) do
            local z = RCM.Layer.InfoWin+i+1
            if item.type == "text" then RCM.Label(vector.create(win.pos.x+10, cy, z), item.text, RCM.Theme.TextDim); cy = cy + 16
            elseif item.type == "link" then 
                local col = RCM.Theme.Link; local lw = 7*#item.text
                if RCM:IsMouseOver(vector.create(win.pos.x+10, cy, 0), vector.create(lw, 14, 0)) then col = RCM.Theme.Accent end
                RCM.Label(vector.create(win.pos.x+10, cy, z), item.text, col); RCM.Rect(vector.create(win.pos.x+10, cy+13, z), vector.create(lw,1,0), col, 1); cy = cy + 16
            elseif item.type == "sep" then RCM.Rect(vector.create(win.pos.x+10, cy+3, z), vector.create(w-20,1,0), RCM.Theme.Border, 0.5); cy = cy + 8 end
        end
    end
end

function RCM:DrawStandardInterface()
    -- Watermark
    if RCM.State.Watermark.Visible then
        local p, t = RCM.State.Watermark.Pos, RCM.State.Watermark.Text
        if RCM.State.Watermark.Extra then 
            local plrName = "Unknown"
            if game and game:GetService("Players") and game:GetService("Players").LocalPlayer then
                plrName = game:GetService("Players").LocalPlayer.Name
            end
            t = t .. " | User: " .. plrName 
        end
        local sz = vector.create((7*#t)+20, 22, 0)
        
        -- [ FIX ] Lock Watermark Logic
        if RCM.State.Enabled and not RCM.State.InputBusy then
            -- Only allowed if Edit Mode is Active
            if RCM.State.EditMode and RCM.State.MouseDown and not RCM.State.MouseHeld and RCM:IsMouseOver(p, sz) then 
                RCM.State.Watermark.Dragging = true; RCM.State.Watermark.Offset = vector.create(RCM.State.MousePos.x-p.x, RCM.State.MousePos.y-p.y, 0) 
            end
            if RCM.State.Watermark.Dragging then
                if RCM.State.MouseDown then
                    local raw = vector.create(RCM.State.MousePos.x-RCM.State.Watermark.Offset.x, RCM.State.MousePos.y-RCM.State.Watermark.Offset.y, 0)
                    local dummy = { pos=raw, size=sz } 
                    p = RCM:CalculateDragSnap(dummy, raw); RCM.State.Watermark.Pos = p
                    RCM.State.InputBusy = true
                else RCM.State.Watermark.Dragging = false end
            end
        end
        RCM.Rect(p, sz, RCM.Theme.Border, 1); RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(sz.x-2,sz.y-2,0), RCM.Theme.Background, 1)
        RCM.Rect(p, vector.create(sz.x,2,0), RCM.Theme.Accent, 1); RCM.Label(vector.create(p.x+10,p.y+4,3), t, RCM.Theme.Text)
    end
    
    local startY = 50
    for i=#RCM.Notifications, 1, -1 do
        local n = RCM.Notifications[i]; local el = tick()-n.start; local rem = n.duration-el
        if rem <= 0 then table.remove(RCM.Notifications, i) else
            local bw = (7*#n.text)+20; local px = RCM.State.ScreenSize.x - bw - 20
            RCM.Rect(vector.create(px,startY,200), vector.create(bw,26,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(px+1,startY+1,200), vector.create(bw-2,24,0), RCM.Theme.Background, 1)
            RCM.Label(vector.create(px+10,startY+5,200), n.text, RCM.Theme.Text)
            RCM.Rect(vector.create(px+1,startY+23,200), vector.create((bw-2)*(rem/n.duration),2,0), RCM.Theme.Accent, 1)
            startY = startY + 35
        end
    end

    -- Edit Mode Indicator
    if RCM.State.EditMode and RCM.State.Enabled then
        local st = "LAYOUT EDITOR ENABLED"
        local sw = 7 * #st
        local sp = vector.create((RCM.State.ScreenSize.x/2)-(sw/2), 10, RCM.Layer.Notif)
        RCM.Rect(vector.create(sp.x-5, sp.y-2, 0), vector.create(sw+10, 20, 0), RCM.Theme.Background, 0.8)
        RCM.Label(sp, st, RCM.Theme.EditModeText)
    end

    -- Keybind List
    if RCM.State.KeybindList.Visible and RCM.State.Enabled then
        local itemsToShow = {}
        for _, bind in ipairs(RCM.Binders) do if RCM.State.KeybindList.Mode == "Always" or (RCM.State.KeybindList.Mode == "Active" and bind.active) then table.insert(itemsToShow, bind) end end
        if #itemsToShow > 0 then
            local p = RCM.State.KeybindList.Pos; local mw = 130; for _, b in ipairs(itemsToShow) do local tw = (7*#b.name)+(7*#b.key)+50; if tw>mw then mw=tw end end
            local th = 24 + (#itemsToShow * 18) + 4
            local sz = vector.create(mw, th, 0)
            
            -- [ FIX ] Lock Keybind List Logic
            if not RCM.State.InputBusy then 
                if RCM.State.EditMode and RCM.State.MouseDown and not RCM.State.MouseHeld and RCM:IsMouseOver(p, vector.create(mw, 24, 0)) then 
                    RCM.State.KeybindList.Dragging=true; RCM.State.KeybindList.Offset = vector.create(RCM.State.MousePos.x-p.x, RCM.State.MousePos.y-p.y, 0) 
                end
            end
            
            if RCM.State.KeybindList.Dragging then 
                if RCM.State.MouseDown then
                    local raw = vector.create(RCM.State.MousePos.x-RCM.State.KeybindList.Offset.x, RCM.State.MousePos.y-RCM.State.KeybindList.Offset.y, 0)
                    local dummy = { pos=raw, size=sz }
                    RCM.State.KeybindList.Pos = RCM:CalculateDragSnap(dummy, raw)
                    p=RCM.State.KeybindList.Pos; RCM.State.InputBusy=true 
                else RCM.State.KeybindList.Dragging=false end
            end
            RCM.Rect(p, sz, RCM.Theme.Border, 1); RCM.Rect(vector.create(p.x+1,p.y+1,1), vector.create(mw-2, th-2, 0), RCM.Theme.Background, 1)
            RCM.Rect(p, vector.create(mw, 2, 0), RCM.Theme.Accent, 1); RCM.Label(vector.create(p.x+(mw/2)-20, p.y+5, 3), "Keybinds", RCM.Theme.Text)
            local ky = p.y + 26
            for _, b in ipairs(itemsToShow) do
                local kt = "["..b.key.."]"; local mt = (b.mode=="Hold" and "[H]") or (b.mode=="Toggle" and "[T]") or "[A]"
                RCM.Label(vector.create(p.x+5, ky, 3), b.name, RCM.Theme.Text)
                RCM.Label(vector.create(p.x+mw-(7*#kt)-(7*#mt)-10, ky, 3), kt..mt, b.active and RCM.Theme.Accent or RCM.Theme.TextDim)
                ky = ky + 18
            end
        end
    end
end

function RCM:DrawPopup()
    if not RCM.State.ActivePopup then return end
    local p = RCM.State.ActivePopup; local pos = p.Pos
    local opts, title = {}, ""
    
    if p.Type == "Binder" then
        title = "Bind Mode"
        opts = {"Hold", "Toggle", "Always"}
    elseif p.Type == "Widget" then
        title = "Layer Order"
        opts = {"Bring to Front", "Send to Back"}
    end
    
    local w, h = 120, (#opts*20)+24
    RCM.Rect(pos, vector.create(w, h, 20), RCM.Theme.Border, 1)
    RCM.Rect(vector.create(pos.x+1, pos.y+1, 20), vector.create(w-2, h-2, 0), RCM.Theme.Background, 1)
    RCM.Label(vector.create(pos.x+5, pos.y+4, 21), title, RCM.Theme.Accent)
    
    local cy = pos.y + 22
    for _, m in ipairs(opts) do
        local op = vector.create(pos.x+2, cy, 20); local os = vector.create(w-4, 18, 0)
        local hov = RCM:IsMouseOver(op, os)
        if hov then
            RCM.Rect(op, os, RCM.Theme.Accent, 0.8)
            if RCM.State.MouseDown and not RCM.State.MouseHeld then 
                if p.Type == "Binder" then p.BindItem.mode = m
                elseif p.Type == "Widget" then
                    if m == "Bring to Front" then RCM:ReorderWidget(p.Obj, "Front")
                    elseif m == "Send to Back" then RCM:ReorderWidget(p.Obj, "Back") end
                end
                RCM.State.ActivePopup = nil; return 
            end
        end
        local col = RCM.Theme.TextDim
        if p.Type == "Binder" and p.BindItem.mode == m then col = RCM.Theme.Text end
        if hov then col = RCM.Theme.Text end
        RCM.Label(vector.create(pos.x+5, cy+2, 21), m, col)
        cy = cy + 20
    end
end

function RCM:Init()
    local ren = RunService.Render or game:GetService("RunService").RenderStepped
    ren:Connect(function()
        RCM.State.InputBusy = false
        RCM.State.ActiveTooltip = nil 
        
        RCM:UpdateInput()
        RCM:UpdateBinders()
        
        RCM:DrawStandardInterface()
        for _, w in ipairs(RCM.Windows) do w:Draw() end
        RCM:HandleDraggableWidgets() 
        
        RCM:DrawInfoWindows()
        RCM:DrawPopup()
        RCM:DrawSnapLines()
        
        if RCM.State.ActiveTooltip and not RCM.State.ActivePopup and RCM.State.Enabled then
            local t, m = RCM.State.ActiveTooltip, RCM.State.MousePos
            local w = (8*#t)+12
            RCM.Rect(vector.create(m.x+12,m.y+12,RCM.Layer.Tooltip), vector.create(w,20,0), RCM.Theme.Border, 1)
            RCM.Rect(vector.create(m.x+13,m.y+13,RCM.Layer.Tooltip), vector.create(w-2,18,0), RCM.Theme.TooltipBg, 1)
            RCM.Label(vector.create(m.x+17,m.y+15,RCM.Layer.Tooltip), t, RCM.Theme.Text)
        end
    end)
end

function RCM:HandleDraggableWidgets()
    for _, wid in ipairs(RCM.Widgets) do
        RCM:HandleDraggable(wid)
        wid.draw()
    end
end

RCM:Init()
return RCM
